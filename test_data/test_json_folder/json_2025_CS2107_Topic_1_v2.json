{
  "1": "Topic 1: Encryption (For Confidentiality) 1.1: Definition: Encryption/decryption/Keys 1.2: Security Model and Requirement 1.3: Classical ciphers + illustration of attacks 1.4: Modern Ciphers  + recommended key length 1.5: Examples of attacks on crypto 1.5.1:  Meet-in-the-middle 1.5.2:  Padding Oracle & notion of \u201cOracle\u201d 1.6: Pitfalls in usages and implementations 1.7: Interesting historical facts To be covered in two weeks. v2 change-log: 1) Minor presentation improvement here and there. 2) Fixed a mistake pointed out by a student in forum. (slide 65 on 3DES. Swap the k1, k2. c =  DESk2 (   DESk1 ( m)     )   ) k2 (   DESk1 ( m)     )   ) (   DESk1 ( m)     )   ) k1 ( m)     )   ) ( m)     )   ) ) 3) For clearer exposition, change the notation k,r, on stream cipher (slide 54-61) so that \u201cr\u201d is for pseudorandom sequence. 4) Add detailed explanation on Sub Perm. (slide 29)",
  "2": "Summary & takeaways (1) \u2022 Encryption is designed for confidentiality.   (not necessary provides integrity, although some method (e.g. AES GCM mode) do.) (not necessary provides integrity, although some method (e.g. AES GCM mode) do.) \u2022 Threat model defines types of attacks to be considered. (threat model is useful in security analysis, not just encryption) (threat model is useful in security analysis, not just encryption) - Attacker\u2019s goal: total break        \u2192 distinguishability \u2192 distinguishability distinguishability - Attacker\u2019s capability: ciphertext only \u2192 plaintext only \u2192 encryption oracle \u2192  decryption oracle. \u2192 plaintext only \u2192 encryption oracle \u2192  decryption oracle. plaintext only \u2192 encryption oracle \u2192  decryption oracle. \u2192 encryption oracle \u2192  decryption oracle. encryption oracle \u2192  decryption oracle. \u2192  decryption oracle. decryption oracle. Defender wants a method that is secure under most \u201chumble\u201d attacker\u2019s goal, and stronger attacker\u2019s capability.  A system S1 is more secure 1 is more secure is more secure than S1 wrt to the threat model, when for any attack that can be prevented in S2, it can also be prevented in S1 1 wrt to the threat model, when for any attack that can be prevented in S2, it can also be prevented in S1 wrt to the threat model, when for any attack that can be prevented in S2, it can also be prevented in S1 2, it can also be prevented in S1 , it can also be prevented in S1 1 \u2022 Notions of \u201cOracle\u201d. - Encryption Oracle, aka CPA (chosen plaintext attack)  (oracle\u2019s output can be obtained from, e.g. smart card, probing of server) (oracle\u2019s output can be obtained from, e.g. smart card, probing of server) - Decryption Oracle.  Padding Oracle Attack (know the detailed mechanism). (oracle output can be derived in many reallife system) (oracle output can be derived in many reallife system) \u2022 Key strength: Quantifying security by equivalence of best-known attack to exhaustive search. (e.g 2048-bit (e.g 2048-bit RSA key  has key strength of ~128 bits. ) \u2022 No known efficient attacks on modern schemes (e.g. AES) under the intended threat models, but there are pitfalls - Implementation error:  using known insecure crypto, wrong mode,  wrong random sources,  mishandling of IV. - side-channel information attack.  (the intended threat model does not consider information available to the attacker that turns out to be feasible) (the intended threat model does not consider information available to the attacker that turns out to be feasible) - Implicitly require integrity.  (the intended threat models does not consider attackers\u2019 goal that turns out to be crucial ) (the intended threat models does not consider attackers\u2019 goal that turns out to be crucial ) 2",
  "3": "Summary & takeaways (2) \u2022 Designs of various symmetric key encryption schemes - One-time pad.    \u201cunbreakable\u201d  even if attacker has sufficient time to exhaustively search. \u201cunbreakable\u201d  even if attacker has sufficient time to exhaustively search. - Stream Cipher.    xor\u2019ing with a \u201cpseudo-random\u201d string. - Block Cipher.   Mode of operations. \u2022 CBC:   provides some form of integrity. (Secure against CPA. vulnerable to padding oracle attack,  BEAST attack, might achieve some forms of (Secure against CPA. vulnerable to padding oracle attack,  BEAST attack, might achieve some forms of integrity.   To secure against BEAST,  IV needed to be unpredictable (random is more general and will do).) *USE THIS WITH CAUTION* \u2022 ECB:   flexible but leak info.  Deterministic (no IV involved). *DO NOT USE* \u2022 CTR:   stream cipher. *USE THIS WITH CAUTION* Secure against CPA;  vulnerable to padding oracle attack if padded. No \u201cintegrity\u201d at all and easily change (aka malleable). If IV of two ciphertext is the same, leak significant information (in contrast, if IV of two ciphertext under CBC is the same, there are some leakage but not as bad). \u2022 GCM: Authenticated-Encryption (AE).  Achieved both integrity & confidentiality. Secure against  Decryption Oracle.  Only standardized quite recently and thus not in some legacy systems. Only standardized quite recently and thus not in some legacy systems. *USE THIS* \u2022 Crucial role of IV.  (need randomness to have indistinguishability) (need randomness to have indistinguishability) - Why? Make the encryption probabilistic. Eg when no IV. - Proper implementation 3",
  "4": "1.1 Definitions 4",
  "5": "Encryption  (Symmetric key) we will see the asymmetric-key version later. 5 Encryption Ek ( ) k ( ) ( ) Decryption Dk () k () () Ciphertext c Plaintext x Plaintext x Key k A cipher must be correct and secure. Correctness: For any plaintext x and key k, Dk (  Ek (x)  ) = x k (  Ek (x)  ) = x (  Ek (x)  ) = x k (x)  ) = x (x)  ) = x Security :  Challenging to define. Definition depend on the threat models .    Informally, from the ciphertext, the eavesdropper is unable to derive useful information of the key k or the plaintext x,  even if  the eavesdropper can probe the system. Remarks:   Encryption could be probabilistic. That is, for the same x, there could be different c\u2019s. Yet they all can be decrypted to the same x. A symmetric-key encryption scheme (also known as cipher. We often drop the term \u201csymmetric-key\u201d for simplicity ) consists of two consists of two algorithms: encryption and decryption.",
  "6": "An application scenario Alice had a large file F (say info on her bank accounts and financial transactions in Excel). She \u201cencrypted\u201d the file F using winzip with a password \u201c13j8d7wjnd\u201d and obtained the ciphertext C. Next, she called Bob to tell him the 10-character password. Subsequently, she sent the ciphertext to Bob via email attachment.    Later, Bob received C and decrypted the ciphertext with the password to obtain the plaintext F . It is possible that Bob and Alice are a same person. Anyone, say Eve,  who had obtained C, without knowing the password, was unable to get any information on F . Although C indeed contained info of F, the information was \u201chidden\u201d. To Eve, C resembled a sequence of random bits.  If Alice sent a truly  random string instead of the actual ciphertext, Eve was not able to distinguish the two. 6 encryption decryption Ciphertext C Plaintext F Plaintext F secret password k Alice Bob secret password k Ciphertext C Remark: \u2022 Winzip is not an encryption scheme. It is an application that employs standard encryption schemes such as AES. \u2022 We need a method to convert password (human generated) to encryption key.  Such method is called KDF, Key Derivation Function. Detail omitted. \u2022 Some zip tools use an insecure crypto ZipCrypto.  Do not use.  Use those with AES. Ciphertext sent via a public channel. Thus, data might be eavesdropped k sent via a secure channel, i.e no one can eavesdrop the info.",
  "7": "Cryptography \u2022 Cryptography is the study of techniques in securing communication in the present of attackers who have access to the communication. \u2022 Although cryptography is commonly associated with encryption, there are other primitives such as cryptographic hash, digital signature, etc. \u2022 Terminology: Common placeholders used in cryptography are Alice (usually the originator of message), Bob (usually the recipient), Eve (eavesdropper: can only listen), Mallory (malicious: can listen and modify messages), (see the interesting list in  https://en.wikipedia.org/wiki/Alice_and_Bob) (see the interesting list in  https://en.wikipedia.org/wiki/Alice_and_Bob) \u2022 Depending on context, Alice may not be a human. She could be the machine that encrypts the message. 7 Alice Bob Eve Remark: Originally, the term cryptography refers to defending methods, cryptanalysis refers to attack methods, and cryptology = cryptography + cryptanalysis.  However, current usage of term cryptography refer to all.",
  "8": "1.2 Threat Model (aka Attack Model, Attack Scenario, Security model, adversary model, etc) \u2022 Formulate security of encryption  by describing the class of attacks it can prevent. \u2022 A class of attacks is described by 1. Attacker\u2019s goal. 2. Attacker\u2019s capability (information, compute resource). 8 For rigorous definition, see crypto textbook: Introduction to Modern Cryptography, 2 [nd] ed,  J. Katz & Y. Lindell.",
  "9": "Threat model 9 Security of a cryptography system, same for many other security systems,  can be described by stating the class of attacks that it can be prevented.  A class of attacks is described by: 1. Attacker\u2019s goal; 2. Attacker\u2019s capability. \u2022 Information given to the attacker \u2022 Computing power In this course, we will not get into details of this. We consider attackers who have access to cloud/supercomputer and reasonable number of years (say 10000 years) to run the compute. Theoretical formulation use the notion of \u201cpolynomial-time\u201d machine. This can be datasets, or services (oracle)  access.",
  "10": "Threat Model: Attacker\u2019s goals \u2022 (Total Break). The attacker wants to find the key. We call this goal total break . \u2022 (Partial Break). The attacker may satisfy with a partial break . There are a few definitions for that.  For instance, the attacker may want to decrypt a ciphertext but not interested in knowing the secret key,  or the attacker may simply want to extract some information about the plaintext. (e.g., whether the plaintext is a JPEG image or an Excel file). (e.g., whether the plaintext is a JPEG image or an Excel file). . \u2022 (Distinguishability) What is the most modest goal? Distinguishability . With some \u201cnon-negligible\u201d probability more than \u00bd, the attacker can correctly distinguish the ciphertexts of a given plaintext (say, \u201cY\u201d) from the ciphertext of another given plaintext (say, \u201cN\u201d). If attacker is unable to distinguish, we call this property indistinguishability ( IND ). - For rigorous definition see the textbook:    J. Katz & Y. Lindell, Introduction to Modern Cryptography, 2nd ed. 10 \u2022 Total break is the \u201cmost difficult\u201d goal in the sense that, if an attacker can achieve total break, the attacker also can achieve partial break and distinguishability.    Distinguishability is the weakest  goal. \u2022 We want to design a secure system that can prevent attacker from achieving the weakest goal. Total Break Partial Break Distinguishability",
  "11": "Threat Models: Attacker\u2019s capability Here are some types of information we assume an attacker has access to. \u2022 Ciphertext only attack : The attacker is given a collection of ciphertext c .     The attacker may know some properties of the plaintext, for e.g. the plaintext is an English sentence. (attacker can\u2019t choose the plaintext). (attacker can\u2019t choose the plaintext). \u2022 Known plaintext attack : The attacker is given a collection of plaintext m and their corresponding ciphertext c . (the attacker can\u2019t (the attacker can\u2019t choose the plaintext. ) \u2022 Chosen plaintext attack (CPA) : The attacker has access to an oracle . The attacker can choose and feed any plaintext m to the oracle and obtain the corresponding ciphertext c (all encrypted with the same key).   The attacker can access the oracle many times, as long as within the attacker\u2019s compute power. He can see the ciphertext and then choose the next input. We  call this black-box an encryption oracle. \u2022 Chosen ciphertext attack (CCA2): Same as chosen plaintext attack, but here, the attacker chooses the ciphertext and the black-box outputs the plaintext. We call the black-box a decryption oracle. 11 Encryption Oracle Secret key ciphertext plaintext Decryption Oracle Secret key ciphertext plaintext Ciphertext only Known Plaintext Chosen Plaintext Chosen Ciphertext",
  "12": "Is it practical to assume the attacker has known plaintext? \u2022 e.g. Attacker might know the header  or part of the plaintext. (e.g. many networks packet header are fixed) \u2022 Eg. Attacker has access to a smartcard. Attacker can query the smartcard to get the ciphertext. \u2022 Eg. Attacker know that after a query Eg. Attacker know that after a query q is sent to a server (e.g. DNS query), the server would construct a  query q\u2019 based on q , encrypt it with a secret key, and then send the ciphertext to another server.  Attacker can eavesdrop and obtain the ciphertext. 12 Is it practical to assume the attacker has access to encryption oracle? plaintext ciphertext Key Services Construct q\u2019 using q Query q Ciphertext of q\u2019 Key",
  "13": "What about decryption oracle ?!?! \u2022 Very strange.  Isn\u2019t it already \u201cGG\u201d if the attacker has a decryption oracle? \u2022 There are practical scenarios where the attacker has access to a weaker form of decryption oracle.  We are getting into detail of an example: Padding Oracle . \u2022 There could be many different weaker forms, potentially some that the defender is not aware of.  But they are all weaker forms of decryption oracle.  If a cipher can defend against decryption oracle, then  the cipher can defend against all other weaker forms. 13 Services Decrypts c to get the plaintext x . If x is a valid instruction, executes it. Otherwise, gives an error message to the sender a byte string c \u201cerror, invalid instruction\u201d \u201cerror, some of the bytes are not ASCII\u201d \u201cerror, the padding format is wrong\u201d \u201cerror, I can only serve query type 06 or 32 (specified by the first two bytes in header)\u201d Key",
  "14": "\u2022 From defender\u2019s point of view,  we want a cipher that can protect against the attacker with the highest capability. \u2022 It turns out that that if a cipher is secure against CCA2, then it is also secure against CPA. \u2022 Unfortunately (or strangely), many systems employ cipher that is only secure against CPA but not CCA2. 14",
  "15": "1.3 Classical Ciphers For illustration, we will investigate a few classical ciphers. Classical ciphers are not secure in the computer era. (exception: the \u201cunbreakable\u201d one-time-pad). (fun to see http://ciphermachines.com/index http://ciphermachines.com/index ://ciphermachines.com/index for a good listing of classical ciphers and cipher machines used during  WWII.) 15 1.3.1. Substitution Cipher 1.3.2.    Permutation Cipher 1.3.3. One time Pad",
  "16": "1.3.1 Substitution Cipher 16",
  "17": "Substitution Cipher \u2022 Plaintext and ciphertext : a string over a set of symbols U. E.g. Let U={\u201ca\u201d, \u201cb\u201d, \u201cc\u201d, \u2026, \u201cz\u201d, \u201c_\u201d}. e.g. of plaintext:  \u201chello_world\u201d \u2022 Key :   a substitution table S, representing an 1-1 onto function from U to U. E.g. \u2022 The key space is the set of all possible keys.  The key space size or size of key space is the total number of possible keys.   The key size or key length is the number of bits required to represent a key. Here, the key space size is (27!), while key size is approximately 94 bits.  (obtained by log2 (27!) ) (obtained by log2 (27!) ) 2 (27!) ) (27!) ) 17 a b c d e f g h i j k l m n o p q r s t u v w x y z _ g v w b n e f h d a t l u c q m z i r s j x o y k _ p S(\u201ca\u201d) = \u201cg\u201d,  S(\u201cb\u201d) = \u201cv\u201d,   \u2026 The inverse of S S [-1] (\u201cg\u201d)=\u201ca\u201d, S [-1] (\u201cv\u201d) = \u201cb\u201d",
  "18": "Substitution cipher:  encryption/decryption Encryption : Given a plaintext, which is a string X= x 1 x 2 x 3 \u2026 x n and the key S,  outputs the ciphertext ES (X) = S(x1) S(x2) S(x3) \u2026 S(xn) S (X) = S(x1) S(x2) S(x3) \u2026 S(xn) (X) = S(x1) S(x2) S(x3) \u2026 S(xn) 1) S(x2) S(x3) \u2026 S(xn) ) S(x2) S(x3) \u2026 S(xn) 2) S(x3) \u2026 S(xn) ) S(x3) \u2026 S(xn) 3) \u2026 S(xn) ) \u2026 S(xn) n) ) E.g. plaintext: h e l l o _ w o r l d ciphertext: h n l l q p o q i l b Decryption : Given a string of ciphertext of length n C = c 1 c 2 c 3 \u2026 c n and the key S,  outputs the plaintext DS(C) =  S S(C) =  S (C) =  S [-1] ( c1 ) S 1 ) S ) S [-1] ( c2 ) S 2 ) S ) S [-1] ( c3 )\u2026S 3 )\u2026S )\u2026S [-1] ( cn) n) ) 18 a b c d e f g h i j k l m n o p q r s t u v w x y z _ g v w b n e f h d a t l u c q m z i r s j x o y k _ p",
  "19": "Exhaustive search (applicable to all encryption schemes) (applicable to all encryption schemes) \u2022 The attacker\u2019s goal is to find the key or to obtain some information of the plaintext. \u2022 A simple attack is to exhaustively search the keys, i.e. examine all possible keys one by one.  Using exhaustive search, eventually (although this might take very long time) the correct key can be found*. \u2022 So, for a cipher to be secure, exhaustive search must be computationally infeasible, e.g. taking millions of years using state-of-the-art supercomputer \u2022 Sophisticated attacks exploit weakness of the encryption scheme so that it can break faster than exhaustive search. 19 *: There are \u201cInformation theoretic secure\u201d  schemes such as one-time-pad that exhaustive search can\u2019t succeed.",
  "20": "Exhaustive search (aka brute-force-search). \u2022 Consider a substitution cipher with table size 27. \u2022 We assume that the attacker knows a ciphertext C and the corresponding plaintext X . The attacker wants to find the key. Let S be the set of all possible substitution tables.  Given X , C . 1. For each S in S 2. Compute  X\u2019 = DS ( S ( ( C );        If    ( X\u2019 == X )   then  break; 3. end-for 4. Display ( \u201cThe key is \u201d,  S ); \u2022 The running time depends on the size of the key space S. \u2022 Since a key can be represented by a sequence of 27 symbols.  The size of key space is  27! (This implies that for any representation of the key, the number of bits required is at least log2 (27!)  \u2248 94   bits.) 2 (27!)  \u2248 94   bits.) (27!)  \u2248 94   bits.) \u2022 Eventually, exhaustive search will find the key. In the worst case, the exhaustive search needs to carry out 27!\u22482 [94] loops. This is infeasible using current compute power (Tutorial 1). 20",
  "21": "Attack: Known-plaintext-attack \u2022 You should have realized that the attacker doesn\u2019t need to carry out exhaustive search.   Given a plaintext and ciphertext (i.e. \u201cKnown plaintext attack\u201d), e.g plaintext: h e l l o _ w o r l d ciphertext: h n l l q p o q i l b The attacker can figure out the entries in the key For sufficiently long ciphertext,  the full table can be found. \u2022 So, substitution chiper is not secure under known plaintext attack. 21 a b c d e f g h i j k l m n o p q r s t u v w x y z _ b n h l q i o p",
  "22": "Attack: Ciphertext only attack \u2022 Ciphertext only attack: The attackers have access to ciphertext only (i.e. without the corresponding plaintext). \u2022 Suppose an attacker knows that the plaintext is an English sentence, can he find the key using exhaustive search under ciphertext only attack ? Yes . Let S be the set of all possible substitution table.  Given C. 1. For each S in S 2. Compute  X = DS (C);   if X contains words in the English dictionary, then break; S (C);   if X contains words in the English dictionary, then break; (C);   if X contains words in the English dictionary, then break; 3. end-for 4. Display ( \u201cThe key is \u201d,  S ); \u2022 Likewise, eventually, the exhaustive search will find the key. However, this attack is computationally infeasible . \u2022 Are there efficient ciphertext only attacks on substitution cipher? Yes. 22",
  "23": "\u2022 Substitution cipher is vulnerable to frequency analysis attack. \u2022 Note that in the hello_world example, \u201c o \u201d appears 2 times in the plaintext, whereas the corresponding \u201c q \u201d also appears 2 times in the ciphertext. \u2022 Suppose the plaintexts are English sentences. The frequency of letters used in English is not uniform, for e.g. \u201c e \u201d is more commonly used than \u201c z \u201d. Given a sufficiently long  ciphertext (say, around 50 characters), attacker may correctly guess the plaintext by mapping frequent characters in the ciphertext to the frequent character in English.   This simple mapping is quite effective. \u2022 Hence, substitution cipher is not secure under ciphertext only attack , when the plaintexts are English sentences. 23",
  "24": "from http://en.wikipedia.org/wiki/Letter_frequency 24 Frequency of letters in English text.",
  "25": "1.3.2 Permutation cipher 25",
  "26": "Permutation  Cipher \u2022 Also known as transposition cipher. The encryption first groups the plaintext into blocks of t characters, and then applied a secret \u201cpermutation\u201d to each block by shuffling the characters. The key is the secret \u201cpermutation\u201d,  which is an 1-1 onto function e from {1,2,..,t} to {1,2,...,t}. The size t could be part of the key, that is, t is also kept secret.  We can write the permutation p as a sequence p = (p1 1 , p2, p3, ... pt) 2, p3, ... pt) , p3, ... pt) 3, ... pt) , ... pt) t) ) which shift the character at position i to  the position pi i . Example: Given  the plaintext and the key t=5, p =(1,5,2,4,3) 26 plaintext ciphertext",
  "27": "Attack \u2022 Permutation cipher fails miserably under known-plaintext attack. Given  a plaintext and a ciphertext,   it is very easy to determine the secret key. in the above, what is the block size t? What is the permutation? \u2022 Permutation cipher is also easily broken under ciphertext only attack if the plaintext is English text. m=     a      a       b       b       b        b       a       b       a        b       a        a c=      b      a       b      a        a        b       b       b       a        b        a       a 27",
  "28": "m=     a      a       b       b       b        b       a       b       a        b       a        a c=      b      a       b      a        a        b       b       b       a         b      a       a 28",
  "29": "Substitution and Permutation cipher https://en.wikipedia.org/wiki/Substitution\u2013permutation_network \u2022 S and P cipher are not secure. \u2022 Performing substitution twice using two tables does not increase difficulty of attack. It simply reduces to one table (try to see why\u2026).  Same for permutation. (SS\u2026S \u2261 S,   PP\u2026P \u2261 P) \u2022 Rounds of substitution and permutation also reduce to one substitution and permutation. (SPSP\u2026SP \u2261 SP) \u2022 However, by interlacing them with some additional tricks, attacks become more difficult.  Indeed, many modern encryption scheme (e.g. AES) is deigned using rounds of S and P.      (optional: see https://en.wikipedia.org/wiki/Substitution\u2013permutation_network ) (optional: see https://en.wikipedia.org/wiki/Substitution\u2013permutation_network ) https://en.wikipedia.org/wiki/Substitution\u2013permutation_network ) ) 29",
  "30": "1.3.3 One Time Pad 30 A B A \u2295 B 0 0 0 0 1 1 1 0 1 1 1 0 A \u2295 B =  (A+B) mod 2 XOR operation Some interesting properties: \u2022 Commutative: A \u2295 B = B \u2295 A \u2022 Associative: A \u2295 ( B \u2295 C ) = ( A \u2295 B ) \u2295 C \u2022 Identity element: A \u2295 0 = A \u2022 Self-inverse: A \u2295 A = 0",
  "31": "One-time-pad Encryption : Given n-bit Plaintext:  x 1, x2, ..., xn , x2, ..., xn 2, ..., xn , ..., xn n and n-bit key:   k1, k2, ..., kn 1, k2, ..., kn , k2, ..., kn 2, ..., kn , ..., kn n ciphertext C=     (x1 1 \u2295 k1), (x2 1), (x2 ), (x2 2 \u2295 k2), (x3 2), (x3 ), (x3 3 \u2295 k3), \u2026, (xn 3), \u2026, (xn ), \u2026, (xn n \u2295 kn) n) ) Decryption : Given n-bit ciphertext:  c1, c2 ,..., cn 1, c2 ,..., cn , c2 ,..., cn 2 ,..., cn ,..., cn n and n-bit key:   k1, k2, ..., kn 1, k2, ..., kn , k2, ..., kn 2, ..., kn , ..., kn n plaintext    X =  (c1 1 \u2295 k 1), (c2 ), (c2 2 \u2295 c 2), (c3 ), (c3 3 \u2295 k 3), \u2026, (cn ), \u2026, (cn n \u2295 k n) ) 31 \u2022 The key cannot be re-used.  That is, a key can only be used once. (Recap that for substitution and permutation cipher, a same key is being used to encrypt multiple plaintexts.) Due to the above requirement, a 1GB plaintext would need a 1GB key to encrypt. Optional: In general, we can replace xor by (x+k) mod N for any integer N, say 256. \u2022 Enc is addition (x+k) mod 256, \u2022 Decryption is subtraction (c-k) mod 256.",
  "32": "E.g.  One-time-pad PlainText 0 0 1 0 1 1 0 Ke y 1 1 0 0 1 1 1 Ci p hertext 1 1 1 0 0 0 1 32 encryption decryption (x \u2295 k ) \u2295 k    = x \u2295 ( k \u2295 k )= (x \u2295 0 ) = x Encryption:     plaintext \u2295 key \u2192  ciphertext ciphertext Decryption:     ciphertext \u2295 key \u2192  plaintext plaintext For any x, k, Correctness (decrypting the ciphertext give back the plaintext): : ciphertext plaintext",
  "33": "Security of one-time-pad \u2022 From a pair of ciphertext and plaintext, the attacker can derive the key.  However, such key is useless, since it will not be used any more. \u2022 Note that even exhaustive search can\u2019t work on one-time-pad. (Suppose we are given a Note that even exhaustive search can\u2019t work on one-time-pad. (Suppose we are given a (Suppose we are given a 1Kbytes ciphertext and are told that the plaintext is a jpeg image.   By using exhaustive search, can we eventually find the plaintext?) \u2022 In fact, It can be shown that one-time-pad leaks no information of the plaintext, even if the attacker has arbitrary running time.  Hence, it is sometime called \u201cunbreakable\u201d. \u2022 CS4236 would study the formulation of \u201cPerfect Secrecy\u201d of one-time-pad. 33",
  "34": "\u2022 The long key renders one-time-pad impractical. \u2022 Nevertheless, it is still relevant in some scenarios. see http://ciphermachines.com/otp and the Venona Story (where one-time-pads fails) (optional: https://www.nsa.gov/Portals/70/documents/about/cryptologic-heritage/historical-figures-publications/publications/coldwar/venona_story.pdf ) 34 http://ciphermachines.com/otp",
  "35": "Intuitively, Perfect Secrecy means: Definition : A cryptosystem  has perfect secrecy if for any distribution X,    for all x , y Pr ( X= x | Y= y ) = Pr (X = x ). 35 Attacker\u2019s prior knowledge of the unknown plaintext x.   (before knowing y) Attacker\u2019s updated knowledge of the unknown plaintext,  after the attacker had seen the ciphertext y. for any ciphertext y and plaintext x,  the chances that  an attacker correctly predicts x before knowing y,  and after knowing y,  are the same.",
  "36": "1.4 Modern Ciphers Modern ciphers generally refer to schemes that use computer to encrypt/decrypt. E.g. RC4, DES, A5, AES, RSA Many modern symmetric ciphers employed rounds of substitution (the so called \u201cS-box\u201d) and permutation. 36",
  "37": "1.4.1  DES/Exhaustive Search 37",
  "38": "Modern ciphers Designs of modern ciphers take into considerations of known-plaintext-attack, frequency analysis and other known attacks.   (Usually, they do not consider CCA2. Fortunately, there are method to convert them to be (Usually, they do not consider CCA2. Fortunately, there are method to convert them to be secure under CCA2) E.g.        DES    (Data Encryption Standard, 1977) broken due to short key RC4    (Rivest\u2019s Cipher 4, 1987) broken A5/1  (used in GSM, 1987) broken ZipCrypto (used in Zip, 1993?) broken \u2026 AES    (Advanced Encryption Standard, 2001)      widely analyzed. Believe to be secure widely analyzed. Believe to be secure They are \u201csupposed\u201d to be secure so that any successful attack does not perform noticeably better than exhaustive search. Remark: Nevertheless,  RC4 is broken in some adoptions. A5/1 also broken and some believe that it is intentionally weak by design. DES\u2019s key length is too short.  Wiki on RC4, A5/1 and DES give quite good description.    AES is believed to be secure. 38",
  "39": "Exhaustive search and key length If the key length is 56 bits,  there are 2 [56 ] possible keys. Hence, the exhaustive search needs to \u201cloop\u201d for 2 [56] times in the worst case. We can quantify the security of an encryption scheme by the length of the key. Consider a scheme A with 64-bit keys and a scheme B with 54-bit keys. Scheme A is more secure w.r.t. exhaustive search. (note that some schemes, e.g. RSA, have known attacks that are more efficient than exhaustively searching all the keys. In those cases, we still want to quantify the security by the equivalent of exhaustive search. For e.g, in the best-known attack on a 2048-bit RSA, roughly 2 [112 ] searches are required. So, its security is equivalent to 112 bits, and we say that the \u201c2048-bit RSA has key strength of 112 bits\u201d). How many bits  is considered \u201csecure\u201d?  (Tutorial 1) read NIST Recommended key length for AES   http://www.keylength.com/en/4/ http://www.keylength.com/en/4/ ://www.keylength.com/en/4/ Remark: The possibility of having Quantum Computers complicates requirement of key-length. We will study this in case-studies during Tutorial. . 39 http://www.keylength.com/en/4/ ://www.keylength.com/en/4/",
  "40": "Exhaustive Search on DES Key length of DES is 56 bits. While exhaustive search on 56 bits seemed infeasible in the 70s, very soon,  it is possible using distributed computing or specialized chip. RSA Security hosted a few challenges on DES.   (Note: .   (Note: (Note: RSA is an encryption scheme, RSA Security is a company, RSA Conference is a well-known conference organized by the company) DES Challenge II-1: The secret message is: \u201dMany hands make light work.\u201d (found in 39 days using distributed computing, early 1998) DES Challenge II-2: The secret message is: \u201cIt's time for those 128-, 192-, and 256-bit keys.\u201d (found in 56 hours using specialized hardware, 1998) 40 EFF\u2019s DES cracking machine. A puzzling question:  Why would a standard chose a scheme that can be broken? Believe to be intentional.",
  "41": "AES 41",
  "42": "AES \u2022 In 2000, a new standard for block cipher, AES (Advance Encryption Standard), was proposed by NIST. The selection process was transparent  with worldwide involvement. \u2022 NIST called for proposal in 1997 and received 21 submissions by Jun 1998. Many rounds of cryptanalysis  on the submissions. In 2000, Rijndael was selected as AES. \u2022 Rijndael was invented by Belgian researchers  Daemen and Rijmen. \u2022 AES block length is 128, and key length can be 128, 192 or 256 bits. \u2022 Currently, no known attacks on AES. (there are some attacks on the mode-of-operation) \u2022 NSA classifies AES as \u201cSuite B Cryptography\u201d. \u201cNSA Suite B Cryptography is a set of cryptographic algorithms promulgated by the by the National Security Agency as part of its Security Agency as part of its as part of its Cryptographic Modernization Program. It is to serve as an interoperable cryptographic base for both unclassified information and most Program. It is to serve as an interoperable cryptographic base for both unclassified information and most . It is to serve as an interoperable cryptographic base for both unclassified information and most classified information.\u201d .\u201d see https://en.wikipedia.org/wiki/NSA_Suite_B_Cryptography y 42",
  "43": "1.4.2  Block cipher & Mode-of-Operations 43",
  "44": "Block Cipher \u2022 DES and AES are also known as \u201cBlock Cipher\u201d. A Block cipher has fixed size of input/output.  E.g.   AES is designed for 128 bits (16 bytes) input/output. \u2022 What?!  Only 128 bits!  How to encrypt the movie!!! \u2022 For large plaintext (say 10 MB),  it is first divided into blocks, and the block cipher is then applied.  The method of extending encryption from a single block to multiple blocks is not straightforward.   It is called mode-of-operation . 44 AES block cipher encryption 128-bit input (plaintext) 128-bit output (ciphertext) Key (can be 128, 192 or 256 bits)",
  "45": "Mode-of-operation:  ECB mode \u2022 Electronic Code Book  naturally is the first to come into our mind. \u2022 It divides plaintext into blocks and then applies block cipher to each block, all with the same key. \u2022 ECB leaks information!! 45 E E E E X1 1 X2 2 X3 3 X4 4 y1 1 y2 2 y3 3 y4 4 plaintext ciphertext k",
  "46": "ECB In the following example, the image is divided into blocks and encrypted with the deterministic block cipher  using the same key. Since it is deterministic,  any two blocks that are the same (for e.g. blocks in the white background) will be encrypted to the same ciphertext. 46 Plaintext ciphertext Remark. An encryption scheme is \u201cdeterministic\u201d in the sense that, the encryption algorithm will always produce the same output (i.e the ciphertext) when given the same input (i.e. the key and plaintext).  In contrast, a \u201cprobabilistic\u201d encryption scheme produces different ciphertext even with the same input (key, plaintext). AES is deterministic.  However, if we employ AES with a randomly chosen IV (to be introduced later), then it is probabilistic.",
  "47": "Mode-of-operation: Cipher Block Chaining (CBC) on AES 47 encryption using the same key k. xor operation each block is 128 bits. plaintext ciphertext Note: In the above figure, we treat IV as part of the final ciphertext. E k E k E k E k Initialization Vector(IV) X1 1 X2 2 X3 3 X4 4 IV c1 1 c2 2 c3 3 c4 4 IV \u2022 The Initialization Vector (IV) is an arbitrary value chosen during encryption. It must be different in different encryptions. \u2022 Complication : o In CBC mode, there is an additional requirement on the IV.  The IV must be \u201cunpredictable\u201d.  The meaning of \u201cunpredictability\u201d is difficult to describe. Fortunately, if the IV is randomly chosen, then it is unpredictable. o In CBC mode, if the IV is predictable, there is an attack known as BEAST attack. (detail not required) (detail not required) y0 = IV.      ci = Ek (xi 0 = IV.      ci = Ek (xi = IV.      ci = Ek (xi i = Ek (xi = Ek (xi k (xi (xi i \u2295 ci-1 )     for i>0 i-1 )     for i>0 )     for i>0 bitwise xor",
  "48": "Cipher Block Chaining (CBC) decryption 48 c 1 c 2 c 3 c 4 IV ciphertext X 1 X 2 X 3 X 4 IV plaintext Intentionally left blank",
  "49": "mode-of-operation: Counter mode (CTR)  Encryption 49 E k E k E k E k IV r 1 r 2 r 3 r 4 IV ciphertext IV+1 IV+2 IV+3 IV+4 X1 1 X2 2 X3 3 X4 4 plaintext c 1 c 2 c 3 c 4 Treat the 128-bit string in a block as a base-2 integer.  Increment it by 1.",
  "50": "Counter mode (CTR) decryption 50 plaintext ciphertet IV c1 1 c2 2 c3 3 c4 4 X 1 X 2 X 3 X 4 Intentionally left blank",
  "51": "Programming example \u2022 Python. (package PyCryptodome https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html) https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html) ) (another package PyCrypto) 51 >>> from Crypto.Cipher import AES >>> >>> key = b'Sixteen-byte key' >>> iv  = b'Sixteen-byte  IV' >>> cipher = AES.new(key, AES.MODE_CBC, iv) >>> c=iv+cipher.encrypt(b'Plaintext of length with multiple of 16    bytes') This key can be randomly chosen or set by user (see crypto pitfalls). Of course, if the key is randomly chosen, it must be securely sent to the receiver and/or store in a secure place. The IV should be randomly chosen. >>> from base64 import * >>> b16encode(c) b'5369787465656E206279746520204956B186083256CACCBD1638AF4877FBF2AAFBECB66FE13C403D7CE8EA04D028E66CA6AE1294 FF51C2F363CCC8953137A6A3' In Python, to display a byte sequence, we can use\u2026 Choose the mode. Remark: the \u201cprogrammer\u201d  chooses the key, iv, and mode. Some programmers are not aware of the implications and thus make mistakes.",
  "52": "GCM mode (Galois/Counter) \u2022 Construction of this mode is more complicated. Details omitted in this class. \u2022 It is an \u201c Authenticated-Encryption\u201d .  The ciphertext consists of an extra tag for authentication (AE to be introduced later). \u2022 It is secure in the presence of decryption oracle. 52",
  "53": "Mode of operations mentioned in this lecture. \u2022 ECB \u2022 CBC \u2022 CTR \u2022 GCM 53 Intentionally left blank",
  "54": "1.4.3  Stream Cipher and IVs CTR mode is a \u201cStream Cipher\u201d. 54",
  "55": "Stream Cipher and one-time-pad A stream cipher has an Initialization Vector(IV).  The IV can be randomly chosen, or from a counter. \u2022 The pseudorandom sequence is generated from the secret key together with the IV.  The final ciphertext contains the IV, followed by the output of the one-time-pad encryption. \u2022 For decryption, the IV is extracted from the ciphertext. From the IV and the key, the same pseudorandom sequence can be generated and thus obtain the plaintext. 55 secret key (say 128 bits) Generator (deterministic) long pseudorandom sequence r 1 r 2 \u2026. r n one time pad encryption (xor) plaintext x1x2\u2026.xn 1x2\u2026.xn x2\u2026.xn 2\u2026.xn \u2026.xn n c IV Ciphertext IV",
  "56": "e.g. 56 Encryption :  Given 15-bit Plaintext x =   0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 secret key k =   0 1 0 1 \u2026\u2026..  1 1 1 0 Step 1: Randomly generates the IV v , v = 0 0 0 1 Step 2: From the secret key k and v , generates a 15-bit sequence r =  0 1 1 0 1 0 1 0 0 1 0 0 1 1 0 Step 3: outputs v and r xor x c = 0 0 0 1    0 1 1 0 1 1 0 1 1 0  0 0 1 1 0 Decryption: Given the key k and the ciphertext c Step 1: Extracts v from c Step 2: From k and v , generates the long sequence r . Step 3: Performs xor to get the plaintext.",
  "57": "Why IV?  What if the IV is always the same? Suppose there isn\u2019t an IV  (or two IVs are the same) Consider the situation where the same key R is used to encrypt two different plaintexts X =  x1, x2, x3, x4, x5 1, x2, x3, x4, x5 , x2, x3, x4, x5 2, x3, x4, x5 , x3, x4, x5 3, x4, x5 , x4, x5 4, x5 , x5 5 and [Y ] [=  y] 1 [, y] 2 [, y] 3 [, y] 4 [, y] 5 An attacker eavesdropped and obtained  the two corresponding ciphertexts U , V . The attacker can now compute U \u2295 V =      ( X \u2295 R ) \u2295 ( Y \u2295 R ) By associative and commutative property of xor U \u2295 V =     ( X \u2295 Y ) \u2295 ( R \u2295 R )  = X \u2295 Y . So, from U and V ,  the attackers can obtain information about X \u2295 Y , i.e. the following sequence (x1 1 \u2295 y1 ), (x2 1 ), (x2 ), (x2 2 \u2295 y2 ), (x3 2 ), (x3 ), (x3 3 \u2295 y3 ), (x4 3 ), (x4 ), (x4 4 \u2295 y4 ), (x5 4 ), (x5 ), (x5 5 \u2295 y5 ) 5 ) ) 57",
  "58": "What so big deal about revealing X \u2295 Y? Suppose X is an  80x120 image of an animal. Each pixel is either black or white (0 or 1). The image can be represented as a  (80x120)-bit sequence where each bit corresponds to a pixel. Y is another 80x120 pixels image rendering two words, which is similarly represented as a sequence. Here is X \u2295 Y. What is X, Y? 58",
  "59": "stream cipher without IV 59 xor xor xor xor R X Y U V",
  "60": "stream cipher with IV 60 xor xor xor xor R 1 X Y R 2 X \u2295 Y \u2295 (R1 1 \u2295 R2) 2) ) U V",
  "61": "Role of IV \u2022 If the IVs are different in two different instances of encryption, , the two pseudorandom sequences will be  different. o xor\u2019ing the two ciphertexts would not cancel out  the pseudorandom sequences. o Even if the two plaintexts are the same, their corresponding ciphertexts are different. \u2022 IV  makes an encryption \u201cprobabilistic\u201d. \u2022 IV is also needed in CBC mode.  The reason is the same.  We want the encryption to be non-deterministic, so that two different encryptions of a same plaintext would give two different ciphertexts. 61",
  "62": "1.5. Examples of attacks 1.5.1 Triple DES & Meet-in-the-middle 1.5.2 Padding Oracle Attack - Notions of Oracle in security analysis - The attack - Implications 62",
  "63": "1.5.1 Triple DES & Meet-in-the-middle attack see http://en.wikipedia.org/wiki/Meet-in-the-middle_attack 63",
  "64": "(d)  Triple DES \u2022 DES is not secure w.r.t. current computing power. One way to improve it is by multiple encryptions: encrypt the plaintext twice or more, using different keys. \u2022 Let us consider double encryption under known plaintext attack. That is, the attacker has a plaintext m and the corresponding ciphertext c ,  and  wants to find the two secret keys k 1 , , k 2 . \u2022 Using exhaustive search,  what is the amount of DES encryption/decryption required?     2 [56+56  ] . So, the key-strength could be 112.  Unfortunately, it is much less than that by \u201cmeet-in-the-middle\u201d attack. 64",
  "65": "Meet-in-the-middle Attack \u2022 Not to confuse \u201cmeet-in-the-middle\u201d with \u201cman-in-the-middle\u201d attack. \u2022 Introduced by Diffie & Hellman in 1977. \u2022 This is a This is a known plaintext attack. We assume attacker has a pair ( m , c )   of  plaintext and the corresponding ciphertext.         That is, attacker has: (m, c =  DESk2 (   DESk1 ( m)     ) k2 (   DESk1 ( m)     ) (   DESk1 ( m)     ) k1 ( m)     ) ( m)     ) \u2022 The attacker\u2019s goal is to find the key, i.e.  k1 and k2. 65",
  "66": "Meet-in-the-middle attack \u2022 Given c and m, find the two keys. 1. Compute two sets C and M . C contains ciphertexts of m encrypted with all possible keys. M contains plaintexts of c decrypted with all possible keys. 2. Find all common elements  (likely to be only one) in C and M .   From the common elements, we can obtain the two keys. \u2022 The above figure, for simplicity,  assumes 3-bit keys.  Using two keys, there are 8x8=64 possibilities. However, the attack only perform 8 encryptions and 8 decryptions.  In general, for k -bit keys, it reduces the number of crypto operations to 2 [k+1] using approximately 2 [k+1 ] units of storage space. 66 plaintext m ciphertext c k 1 =000 k 1 =001 k1 =010 1 =010 =010 k 1 =011 k 1 =100 c0 c1 c2 c3 c4 c5 c6 c7 m0 m1 m2 m3 m4 m5 m6 m7 Encryption Decryption stored in some data structures, e.g. hash table Meet-in-the-middle k 1 =101 k 1 =110 k1 =111 1 =111 =111 k 2 =000 k 2 =001 k 2 =010 k2 =011 2 =011 =011 k2 =100 2 =100 =100 k 2 =101 k 2 =110 k 2 =111",
  "67": "Tradeoff with time and space \u2022 If 2 [k+1] storage is too much, we can have a tradeoff. \u2022 Given m , c .  For each possible value of the last For each possible value of the last s bits of k1  and last 1  and last and last s bits of k2 , do the followings: 2 , do the followings: , do the followings: o Carries out meet-in-the-middle attack (with last s bits of k1, k2 fixed).   If successful, stops the exhaustive 1, k2 fixed).   If successful, stops the exhaustive , k2 fixed).   If successful, stops the exhaustive 2 fixed).   If successful, stops the exhaustive fixed).   If successful, stops the exhaustive search. \u2022 The storage requirement dropped by a factor of 2 [s] ,  but the number of  cryptographic operations increased  by a factor of 2 [2s] . 67 plaintext m ciphertext  c k1=001 1=001 =001 1 k1=011 1=011 =011 1 k1=101 1=101 =101 1 c1 c3 c5 c7 m0 m2 m4 m6 Encryption Decryption stored in an array or hash table. Meet-in-the-middle Last bit of k1 is fixed to  1. 1 is fixed to  1. is fixed to  1. Last bit of k2 is fixed to  0. 2 is fixed to  0. is fixed to  0. Perform meet-in-the-man on the plaintext m first 2 bits of k1 and k2 1 and k2 and k2 2 k1=111 1=111 =111 1 k2=000 2=000 =000 0 k2=010 2=010 =010 0 k2=100 2=100 =100 0 k2=110 2=110 =110 0",
  "68": "3DES \u2022 Remedy---   Use Triple encryptions, but 2 keys. a) Ek1 ( Ek2 k1 ( Ek2 ( Ek2 k2 (Ek1  ( x ) ) ). k1  ( x ) ) ). ( x ) ) ). or b) Ek1 ( Dk2 ( Ek1 (x ) ) ). k1 ( Dk2 ( Ek1 (x ) ) ). ( Dk2 ( Ek1 (x ) ) ). k2 ( Ek1 (x ) ) ). ( Ek1 (x ) ) ). k1 (x ) ) ). (x ) ) ). Both (a) and (b) are believed to have the same level of security. However, version (b) can be more convenient. By choosing K1=K2, then it is same as single encryption. \u2022 Other variants 3DES, TDES, TDEA, 2TDES, 3TDES (using 3 keys) 68",
  "69": "\u2022 Meet-in-the-middle take ~2 [112] encryption/decryption.  Can it be faster? Interestingly yes. Lucks improved it to 2 [108 ] DES operations. [Lucks1998]  S. Lucks, Attacking Triple Encryption , FSE 1998. \u2022 Triple DES was still in used until recently. - VISA  seems to support it until Oct 2020 https://usa.visa.com/dam/VCOM/global/support-legal/documents/visa-file-exchange-service-key-exchange-key-algorithm.pdf - (3DES was the default encryption in Outlook 2007. See its help page:  http://office.microsoft.com/en-sg/outlook-help/encrypt-messages-HP006369952.aspx http://office.microsoft.com/en-sg/outlook-help/encrypt-messages-HP006369952.aspx 69",
  "70": "1.5.2 Padding Oracle Attack 70 https://images.app.goo.gl/UwpN6vVkBygBEW77A",
  "71": "Oracle in security analysis \u2022 Recap that in security analysis, it is important to formulate     (1) what information the attackers have; (2) attackers\u2019 goals. \u2022 One type of information is obtained via a query-answer system, known as Oracle. The attackers can send in queries, and the Oracle will output the answers.   E.g. - Encryption Oracle. On query a plaintext x ,  the oracle outputs the ciphertext E k ( x ) where the key k is a secret key. - Decryption Oracle. On query a ciphertext c ,  the oracle outputs the plaintext D k ( x ) where the key k is a secret key. \u2022 While encryption oracle make sense,  it is not immediately clear why we need to consider attacker with decryption oracle.  Padding oracle attack illustrates the need. 71 Encryption Oracle (secret k) x c = Ek(x) k(x) (x) decryption Oracle (secret k) c x = Dk(c) k(c) (c)",
  "72": "Padding Format \u2022 The block size of AES is 128 bits (or 16 bytes).    Suppose the length of the plaintext is 25 bytes, it will be fitted into two blocks, with the remaining 7 bytes \u201cpadded\u201d with some values. \u2022 There are many ways to fill in the values.   In any case, an important piece of information must be encoded:  the number of padded bits.   If this info is missing,  the receiver will not know the length of the plaintext. \u2022 Next slide describes a padding \u201cstandard\u201d. 72 16 bytes 9 bytes 7 bytes",
  "73": "Padding -  PKCS#7 \u2022 PKCS#7 is a padding standard. https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7 \u2022 The following example is self-explanatory. Suppose the block size is 8 bytes , and the last block has 5 bytes (thus 3 extra bytes required), padding is done as follow: DD DD DD DD DD DD DD DD      DD DD DD DD DD 03 03 03 \u2022 In general, the paddings are: 01 02 02 03 03  03 04 04 04  04 .... 08 08 08 08 08 08 08 08 \u2022 If the last block is full, i.e. it has 8 bytes, an extra block is added  where each byte  is 08  (i.e the block size). 73",
  "74": "Padding Oracle attack The attack model: \u2022 What the attacker has: - A  ciphertext   (iv, c ).       The ciphertext is encrypted using a secret key k. - Access to a Padding Oracle. \u2022 Attacker\u2019s  goal: - Find the plaintext of   (iv, c ) \u2022 Padding Oracle: - Query:    Any ciphertext . - Output:  YES,     if the plaintext is in the correct \u201cpadding\u201d format. NO,      otherwise 74 Padding Oracle Secret key ciphertext YES / NO",
  "75": "Padding oracle attack on AES CBC mode (AES block is 16 bytes, for ease of presentation, we consider 8-byte block here) \u2022 AES CBC mode is not secure against padding oracle attack. For ease of illustration, let\u2019s assume: \u2022 The block size is 8 bytes; \u2022 The c  is only 1 block; \u2022 The attacker knows that the block is padded with 3 bytes; \u2022 The attacker is only interested in the value of x5. 5. 75 iv = v 1 v 2 v 3 v 4 v 5 v 6 v 7 v 8 c = c 1 c 2 c 3 c 4 c 5 c 6 c 7 c 8 x = x 1 x 2 x 3 x 4 x 5 03 03 03 ? ? ? ? ? Attacker knows that the last 3 bytes must be 03. Attacker knows the IV Attacker knows the C Attacker doesn\u2019t know x 1 x 2 x 3 x 4 x 5 Main idea The attacker knowledge before the attack plaintext",
  "76": "1. Calculates iv\u2019 from iv by xor the last 4 bytes (see figure), where (see figure), where , where t is set to some value, say t =0. 2. Feeds the padding oracle with  (iv\u2019, c). 3. If the oracle outputs YES,  then (x5 x5 5 \u2295 t )  must be of the value 04. Outputs (04 must be of the value 04. Outputs (04 \u2295 t ) and halts.            (WHY?) 4. If NO,  repeats the process with another value of t . 76 iv\u2019 = v 1 v 2 v 3 v 4 v 5 v 6 v 7 v 8 c = c 1 c 2 c 3 c 4 c 5 c 6 c 7 c 8 x = x 1 x 2 x 3 x 4 x 5 03 03 03 0 0 0 0 t 07 07 07 \u2295 x 1 x 2 x 3 x 4 04 04 04 Original iv and c decrypted to this. New      iv\u2019 and c decrypted to this. x\u2019 = x5 5 \u2295 t The attacker carries out these steps. The output is value of x5 5 : Padding Oracle (iv\u2019, c) YES / NO C \u2026 IV \u2022 CBC mode Decryption dk k dk k 03 By using the new iv\u2019, last byte of the decrypted plaintext changes to 04 The attacking steps 3 =  0 1 1 4 =  1 0 0 7 =  1 1 1 last byte",
  "77": "Padding oracle attack \u2022 This algorithm outputs the value of x5 5 . 1. For t = 00 to FF          // hexadecimal  representation, i.e. 0 to 255 in decimal 2.        Let v = iv \u2295 3.        Sends the two-block query ( v , c )  to Oracle . 4.        If Oracle gives YES ,  then  outputs   (04 \u2295 t) 5. End-for-loop 77 0 0 0 0 t 07 07 07 Decryption Oracle (secret k) (v, c) Yes iff the plaintext is correctly padded. C \u2026 IV \u2022 CBC mode Decryption dk k dk k x",
  "78": "Remarks \u2022 We can easily extend the algorithm to find the full plaintext. \u2022 There is still a gap. The algorithm needs to know the initial padding length. Fortunately, it is easy to determine the length  (exercise). \u2022 This attack is practical.  There are  protocols between a client  and server which performs this: If the client submits a ciphertext whose plaintext is not padded correctly, the server will reply with an error message. \u2022 Now, if an attacker obtained a ciphertext, the attacker could interact with the server to get the plaintext. 78",
  "79": "79 https://vulert.com/vuln-db/CVE-2021-29443",
  "80": "Prevention of padding-oracle attack. \u2022 One method is to deny access to such oracle.  Might not be feasible  in some applications. \u2022 Changing the padding standard may mitigate the attack. However, there could be other smarter way to attack the new padding. \u2022 CTR mode also vulnerable to padding oracle. \u2022 Padding oracle is a weaker form of Decryption oracle. Schemes that are secure against decryption oracle are also known as IND-CCA2 secure (indistinguishability, adaptive chosen ciphertext attack). GCM, or . GCM, or other \u201cauthenticated encryption\u201d,  is believed to be IND-CCA2 secure and thus secure against padding oracle attack. 80",
  "81": "1.6 Cryptography Pitfalls A secure encryption scheme can be vulnerable if not implemented or adopted properly.  This section gives some examples. 1.6.1 \u2013 Wrong choice of IV   (already discussed) (already discussed) 1.6.2 \u2013 Randomness is predictable 1.6.3 \u2013 Modify existing or design your own encryption scheme 1.6.4 \u2013 Reliance on Obscurity: Kerckhoff\u2019s principle. (already discussed) \u2013 Presence of decryption oracle but use a crypto that is not CCA2 secure. (to be discussed in another topic) \u2013 Using encryption for integrity (very subtle in some scenario) (very subtle in some scenario) \u2013  Side Channel Attack 81",
  "82": "1.6.1  Wrong choices of IV.  Reusing one-time-pad 82",
  "83": "Wrong choices of IV Some implementation overlooked IV generation. IV\u2019s must not be the same for two different ciphertexts. \u2022 E.g.  To encrypt a file F, the IV is derived from the filename/meta-data.  It is quite common to have files with the same filename/meta-data. (Read Read Schneier on Security, Microsoft RC4 Flaw. https://www.schneier.com/blog/archives/2005/01/microsoft_rc4_f.html ://www.schneier.com/blog/archives/2005/01/microsoft_rc4_f.html http://eprint.iacr.org/2005/007.pdf  ) ://eprint.iacr.org/2005/007.pdf  ) ) \u2022 E.g.  When using AES under the \u201cCBC mode\u201d, the IV should be unpredictable to prevent a certain type of attack.    (So, it is vulnerable to choose IV as  1,2,3,....) The well-known BEAST attack exploits this. (optional: http://resources.infosecinstitute.com/ssl-attacks/ ) http://resources.infosecinstitute.com/ssl-attacks/ ) ://resources.infosecinstitute.com/ssl-attacks/ ) ) 83",
  "84": "\u2022 The Verona project is a classic example on such failure. (optional:  https://www.nsa.gov/about/_files/cryptologic_heritage/publications/coldwar/venona_story.pdf  ) https://www.nsa.gov/about/_files/cryptologic_heritage/publications/coldwar/venona_story.pdf  ) ) 84 Reusing one-time-pad",
  "85": "1.6.2  Predictable secret generation (tutorial) 85",
  "86": "\u2022 Scenario 1 : - You are coding a program for a simulation system, for e.g. to simulate road traffic. - In the program, you need a sequence of  random numbers, for e.g. to decide the speed of the cars. - How to get these random numbers? \u2022 Scenario 2 : - You are coding a program for a security system. - In the program, you need a random number.  For e.g. you need to generate a random number as a temporary secret key. - How to get these random numbers? 86",
  "87": "to be discussed in tutorial \u2022 In Java, what is the different between the following? - java.util.Random - java.security.SecureRandom \u2022 In C, what is the different between using the following #include <time.h> #include <stdlib.h> srand(time(NULL)); int r = rand(); and a complicated version below? int byte_count = 64; char data[64]; FILE *fp; fp = fopen(\"/dev/urandom\", \"r\"); fread(&data, 1, byte_count, fp); fclose(fp); 87",
  "88": "1.6.3  Designing your own cipher 88",
  "89": "\u2022 Don\u2019t design your own crypto or even make slight modification to existing scheme. \u2022 Use well-accepted algorithms.  E.g. AES. \u2022 If possible, use well-established library.   Don\u2019t write code to implement  AES. - We might implement wrongly. - We might implement it insecurely. E.g. buffer overflow vulnerability, and side-channel attack. \u2022 \u201cDon\u2019t roll your own crypto\u201d read http://security.stackexchange.com/questions/2202/lessons-learned-and-misconceptions-regarding-encryption-and-cryptology/2210#2210 ://security.stackexchange.com/questions/2202/lessons-learned-and-misconceptions-regarding-encryption-and-cryptology/2210#2210 89",
  "90": "1.6.4  Reliance on Obscurity: Kerckhoffs\u2019s Principle 90",
  "91": "Kerckhoffs\u2019s principle A system should be secure even if everything about the system, except the secret key, is public knowledge. To hide the design of the system to achieve security. 91 Security through Obscurity",
  "92": "Examples (against obscurity) \u2022 RC4 was introduced in 1987 and its algorithm was a trade secret. In 1994, a description of its algorithm was anonymously posted in a mailing group. http://en.wikipedia.org/wiki/RC4 ://en.wikipedia.org/wiki/RC4 \u2022 MIFARE Classic is a contactless smartcard widely used in Europe. It uses a set of proprietary protocols/algorithms.  However, they are reverse-engineered in 2007. It turns out that the encryption algorithms are already known to be weak (with 48-bit keys) and breakable. http://en.wikipedia.org/wiki/MIFARE ://en.wikipedia.org/wiki/MIFARE Presentation (video) by the researcher who reversed-engineered it: see http://www.youtube.com/watch?gl=SG&hl=en-GB&v=QJyxUvMGLr0 ://www.youtube.com/watch?gl=SG&hl=en-GB&v=QJyxUvMGLr0 (the algo was revealed at 14:00) Lecture 0 page 92",
  "93": "Examples (for obscurity) \u2022 It is not advisable to reveal the computer network structure and settings (for example, location of firewall and the firewall rules), although these are not \u201csecrets\u201d, and many users within the organization may already know the settings. \u2022 Although it is advisable to make the algorithm public, it is not advisable to publish the actual program used in a smart-card.  By publishing the program/code, advisory may be able to identity implementation flaw that was previously unaware of or carry out side-channel attacks. \u2022 Usernames are not secret. However, it is not advisable to publish all the usernames. There is no contradiction. \u2022 In general, obscurity can be used as an addition layer in the defense-in-depth strategy. It could deter or discourage novice attackers, but ineffective against attackers with high skill and motivation.  We cannot rely solely on obscurity for security. see http://technet.microsoft.com/en-us/magazine/2008.06.obscurity.aspx http://en.wikipedia.org/wiki/Security_through_obscurity Lecture 0 page 93",
  "94": "In this course, we always assume that the attackers know the algorithms. 94",
  "95": "Others \u2022 We have seen Padding oracle attack. In this attack, the attacker can modify the ciphertext, which can be viewed as compromise of \u201cintegrity\u201d. \u2022 Side-channel attack.   To be introduced later. 95",
  "96": "1.7 Some historical facts 96",
  "97": "Cryptography: History \u2022 Cryptography is closely related to warfare and can be traced back to ancient Greece.  Its role became significant when information is sent over-the-air. Cryptanalysis is one of the driving forces to the invention of computer (e.g. Colossus computer https://en.wikipedia.org/wiki/Colossus_computer). https://en.wikipedia.org/wiki/Colossus_computer). ). \u2022 WWII:  Famous encryption machines include the Enigma, and  the Bombe (that helped to break Engima). 97",
  "98": "http://www.enigma-replica.com/Glens_Enigma.JPG Enigma. \u201cCompute\u201d using Electrical + Mechanical mechanisms plugboard (secret key. A vulnerability significantly reduces the search space) ) Keyboard (plaintext) lampboard (ciphertext) Rotors: choices of rotors and starting position choices of rotors and starting position (secret key) Cables connecting the plug",
  "99": "99 Working rebuilt bombe at Bletchley Park museum. http://en.wikipedia.org/wiki/Cryptanalysis_of_the_Enigma#Crib-based_decryption simulates the 3 rotors in one Enigma machine Exhaustive search on choices of rotors + some smart trick to search plug cable config.",
  "100": "Movie about encryption 100 The Imitation Game. During World War II, mathematician Alan Turing tries to crack Enigma with help from fellow mathematicians. http://www.imdb.com/title/tt2084970/ U-571 Fictional plot on how a U-boat was captured.  Actual U-boat captured:  U-110, U-505, U-570, U-744, U-1024. Prize of capturing a U-boat instead of sinking it:  Engima. https://en.wikipedia.org/wiki/U-571_%28film%29",
  "101": "Modern Ciphers DES \u2022 1977:  DES (Data Encryption Standard), 56 bits. During cold war, cryptography, in particular DES was   considered as \u201cMunition\u201d, and subjected to export control.  (Currently, export of certain cryptography products is still controlled by US.) .  (Currently, export of certain cryptography products is still controlled by US.) Read the section on Singapore in http://www.cryptolaw.org/cls2.htm \u2022 1998:  A DES key broken in 56 hours. Triple DES (112 bits)  is still in used. \u2022 2001:  AES (Advanced Encryption Standard). NIST. 128, 192, 256 bits. RC4 \u2022 Designed by Ron Rivest (RSA Security)  in 1987. \u2022 Initially a trade secret. Algorithm leaked in  1994. \u2022 Used in WEP (for wifi)  in 1999.  WEP implementation has 40  or 104-bit key. WEP was widely popular. \u2022 2001: a weakness in how WEP adopts RC4 is published by Fluhrer, Mantin, Shamir. \u2022 2005:  a group from FBI demonstrated the attack. \u2022 Industry switched to WPA2.    (with WPA as a transition and temporary  solution). 101"
}