{
  "1": "Topic 3: Authenticity (Data Origin) 3.1. Crypto Primitive:  Public Key Cryptography 3.1.1  RSA 3.1.2  Security of RSA 3.1.3  Remarks 3.2  Data Authenticity (Hash): Unkeyed hash 3.3  Data Authenticity (Mac) : Keyed Hash 3.4  Data Authenticity (Signature): Asymmetric key. 3.5  Some attacks & pitfalls 3.5.1 Birthday attack on hash 3.5.2 Design flaw: using encryption for authenticity 3.5.3 Time-Space tradeoff 3.6  Other applications of Hash: password file protection    (in Topic 2) Remark: \u2022 In Topic 2, we mentioned two modes of authentication. Topic 3: Data Origin (crypto primitive);  Topic 4: Communicating Entity (authentication protocol). \u2022 Public key encryption logically should be covered in Topic 1.  However, we have it here for better flow. Change Log v1: 1. Minor non-essential improved presentation here and there. 2. Slide 71, 72. Added the phrase \u201cfor message not seen before\u201d. 3. Slide 13, typo on 2 [n]",
  "2": "Summary & takeaways \u2022 Public Key Encryption. - RSA  (based on integer factorization. Only integer).   ElGamal  (based on discrete log of \u201cAlgebraic group\u201d. Many choices: ECC). - Differences with symmetric key.   Implications: \u2022 Symmetric key requires a Symmetric key requires a secure channel to distribute key. \u2022 Public key requires  a Public key requires  a secure broadcast channel to distribute key. - Post-Quantum Crypto (implication after  quantum computer become available) - Pitfall: using RSA in symmetric key setting. Using textbook RSA. \u2022 Authentication primitives: digest, mac, signature. - Security models and application scenarios  (Summary Slide 73,74,75) - Digest \u2022 No key or other secret information in hash/digest. \u2022 Hash requirement:   Collision resistant.   Collision resistant vs 2 Hash requirement:   Collision resistant.   Collision resistant vs 2 [nd] pre-image attack. \u2022 All hash subjected to Birthday attacks. All hash subjected to Birthday attacks. - Signature vs mac \u2022 (advantage) only require secure broadcast channel;  non-repudiation. \u2022 (disadvantages):   efficiency. \u2022 Achieve Confidentiality                  Achieve  Authenticity       (if a scheme preserves confidentiality, it might not preserve authenticity) (if a scheme preserves confidentiality, it might not preserve authenticity) \u2022 Construction: - hash: SHA - Mac: CBC-mac, HMAC - Signature: DSA, hash-and-sign.     Special property of RSA for signature (hash-and-encrypt). \u2022 Time-memory-tradeoff in inverting hash 2",
  "3": "3.1.  Public Key Cryptography (PKC) Public Key Crypto primitives include public key encryption and signature. The goal of  Public Key Encryption is for confidentiality, while the goal of signature is for authenticity. 3",
  "4": "Public Key Encryption A symmetric-key encryption scheme uses the same key for encryption and decryption. 4 Encryption Ek ( ) k ( ) ( ) Decryption Dk () k () () ciphertext c Plaintext x Plaintext x Key k",
  "5": "Overview A public key (aka asymmetric-key) (aka asymmetric-key) scheme uses different keys for encryption and decryption. Note on definitions: \u2022 Decryption algo also takes in  the public key. \u2022 In literature, some include ke as part of private key, but some don\u2019t. In this lecture, we take the convention: e as part of private key, but some don\u2019t. In this lecture, we take the convention: as part of private key, but some don\u2019t. In this lecture, we take the convention: Public key:  ke,    Private key: kd,    Decryption key: (ke, kd) e,    Private key: kd,    Decryption key: (ke, kd) ,    Private key: kd,    Decryption key: (ke, kd) d,    Decryption key: (ke, kd) ,    Decryption key: (ke, kd) e, kd) , kd) d) ) For abbreviation, many would say \u201cusing private key to decrypt\u201d.  This implicitly means using both the private and public key to decrypt. 5 Encryption E (ke, x) e, x) , x) Decryption D ( \u27e8 ke, kd e, kd , kd d \u27e9 ,  c) ciphertext c Plaintext x Plaintext x Public key ke e Private key k d Decryption  key: \u27e8 ke, kd e, kd , kd d \u27e9",
  "6": "Why called \u201cpublic key\u201d? \u2022 The owner Alice keeps the private key as a secret but  tell everyone the public key (for eg. posts in her Facebook).    Everyone knows the public key. \u2022 An entity, Bob, has a plaintext  x for Alice. Bob can encrypt it (using the public key ) and posts the ciphertext c on Alice\u2019s Facebook. \u2022 Another entity, Eve, obtains the public key, and ciphertext c from the Alice\u2019s Facebook.  Without the private key, Eve is unable to derive x. \u2022 Alice, with the private key and the public key , can decrypt and obtain the plaintext x. 6 Encryption E(ke, x ) e, x ) , x ) Decryption D( \u27e8 ke,kd e,kd ,kd d \u27e9 , c ) ciphertext c Plaintext x Plaintext x Public key ke e Private key kd d Hello everybody, this is my public key X23kavlaem3q4?a!f+35X#;c3s%$^ 314d8zf34gsfg$#VDSDF73SGDSFe Yes, lol couldn\u2019t get it This example illustrates usage of public key for encryption.  In practice, it is more common to employ PKC for \u201cauthentication\u201d.",
  "7": "Security Requirements of a Public Key Encryption \u2022 Threat model: - Given the public key and the ciphertext (but not the private key), the attacker wants to get info of the plaintext; \u2022 To be secure under the above, it must be difficult for the attacker to get the private key from the public key. Remark: \u2022 Recap that \u201cindistinguishability\u201d is the modest goal. \u2022 Encryption Oracle : With the public key, anyone can encrypt. So, the attacker always has access to the \u201cencryption oracle\u201d. 7",
  "8": "What so useful about public key? \u2022 Suppose we have multiple entities, A 1 , A 2, \u2026, , \u2026, A n : - Each of them can compute a pair of \u27e8 private key, public key \u27e9 - Each broadcast his/her public key, but keeps the private key secret \u2022 Now,  suppose Ai i wants to encrypt a message m for Aj j only: - A i can use A j \u2019s public key to encrypt m - By the property of PKC, only A j can decrypt it \u2022 If we don\u2019t use the PKC, then, any two entities must share a symmetric key via a secure channel.   Implications: - Many keys are required in symmetric keys; - Symmetric key requires both entities to know each other before the actual communication session. In contrast, PKC can handle such scenario.  (e.g. You want to send a message to (e.g. You want to send a message to www.bbc.com. Does www.bbc.com know you? know you? Likely no.  If www.bbc.com doesn\u2019t know you,  it is impossible to set up a secure channel for you and www.bbc.com to establish a shared www.bbc.com doesn\u2019t know you,  it is impossible to set up a secure channel for you and www.bbc.com to establish a shared doesn\u2019t know you,  it is impossible to set up a secure channel for you and www.bbc.com to establish a shared www.bbc.com to establish a shared to establish a shared symmetric key.   Now,   with PKC,  www.bbc.com can first broadcasts its public key. Even an entity  whom www.bbc.com can first broadcasts its public key. Even an entity  whom can first broadcasts its public key. Even an entity  whom www.bbc.com doesn\u2019t know can get the doesn\u2019t know can get the public key.) 8",
  "9": "Keys Distribution 9 Symmetric key setting: Individual secure channel for each pair Public key setting: Secure Broadcast Channel A1 1 A4 4 A5 5 A2 2 A3 3 Every pair of entities requires one key. We need a secure channel to distribute that key. Let ki,j  to be the key to be shared by Ai and Aj i,j  to be the key to be shared by Ai and Aj to be the key to be shared by Ai and Aj i and Aj and Aj j k1,2,  k1,3,  ..... 1,2,  k1,3,  ..... ,  k1,3,  ..... 1,3,  ..... ,  ..... Total number of keys: n(n-1)/2 k 1,5 A1 1 A4 4 A5 5 A2 2 A3 3 k e,1 kd,1 d,1 k e,2 k e,2 Each entity publishes its public key Entity Ai  publish ke,i and keep kd,i i  publish ke,i and keep kd,i publish ke,i and keep kd,i e,i and keep kd,i and keep kd,i d,i Total number of public keys: n Total number of private keys: n Advantages: \u2022 Fewer keys. \u2022 Entities don\u2019t need to know each other before broadcasting the keys.",
  "10": "\u2022 Symmetric key :  We need a secure channel to establish the secret key for any two entities. \u2022 Public key :   We only need a secure broadcast channel to distribute the public key. 10",
  "11": "Remark \u2022 Although easier than setting up individual channels,  setting up a secure broadcast channel for public key is still challenging. (whole lecture on PKI in Topic 4) \u2022 While we introduce PKC for encryption,  an important application  of PKC is in authentication (e.g. HTTPS). e.g. HTTPS). ). \u2022 PKC has limitations compare to symmetric key such as AES. - Efficiency: key size and compute time; - Security: many current popular PKC are vulnerable to quantum computer; 11",
  "12": "Popular PKC schemes \u2022 RSA: - Operate on integer modulo.   (optional remark. Need both multiplication and addition.  i.e. need a \u201cfield\u201d) (optional remark. Need both multiplication and addition.  i.e. need a \u201cfield\u201d) - Recommended Key size \u2248 2048 bits \u2022 ElGamal: - ElGamal can operates in other choices of algebraic groups.    (optional remark: need only one group operator) (optional remark: need only one group operator) - E.g, Elliptic Curve Cryptography (ECC), which requires key size ~300 bits for equivalent of ~2048 in RSA. \u2022 Paillier:  homomorphic with respect to addition. \u2022 Post-Quantum cryptography:   Quantum computer breaks RSA. Crypto that is secure against quantum computer is called \u201cpost-quantum cryptography\u201d. Quantum computer not here yet. 12 Rivest, Shamir and Adleman, 2002 Turing Award. Diffie and Hellman 2015 Turing Award The idea of asymmetric public-private key cryptosystem is attributed to Whitfield Diffie and Martin Hellman, who published the concept in 1976. Ron Rivest, Adi Shamir, and Leonard Adleman proposed RSA algorithm in 1977.",
  "13": "Integer representations \u2022 We will introduce the \u201ctextbook\u201d RSA, i.e. the basic form of RSA.  We call it \u201ctextbook\u201d because the basic form is We call it \u201ctextbook\u201d because the basic form is not secure. In practice, some forms of padding required and there are special considerations in choosing the primes. \u2022 RSA represents the data (plaintext, ciphertext, key) as integers.  The integers can be represented using binary representations. Note that a n- bit number ranges from 0 to 2 [n] -1.    (e.g. a 3-bit integer is a value (e.g. a 3-bit integer is a value from 0 to 7) \u2022 Since the number of 1024-bit integers are 2 [1024] ,  hence, an algorithm that exhaustively searches  all 1024-bit numbers is infeasible. 13",
  "14": "3.1.1  RSA - Textbook RSA:    algo that taught in many \u201cnon-security\u201d modules. In practice: - Padded RSA.  (to destroy some property) - Choose strong primes. - Fast and secure way to generate primes. - Secure implementation to guard against side-channel attack. - the \u201ce\u201d is fixed, typically fixed as 65537 - Quantum Computer. 14",
  "15": "\u201cTextbook RSA\u201d -  setup 1. Owner randomly chooses 2 large primes p , q and computes n = pq . 2. Owner randomly chooses an encryption exponent e s.t.  gcd( e , (p-1)(q-1) ) =1. (i.e.  e does not have common factor with (p-1) or (q-1).) 3. Owner finds the decryption exponent d where d e mod ( p -1)( q -1)  =1 There is an algorithm that finds d when given e, p and q.  We won\u2019t get into the details, The term  ( p -1)( q -1) = \u0424( n )  is aka the Euler\u2019s totient function,  which  is the number of co-primes < n. 4. Owner publishes \u27e8 n , e \u27e9 as public key,  and safe-keeps d as the private key.    (note (note that owner doesn\u2019t need to keep p, q.   The e is not required during decryption.) \u2022 Encryption, Given m , the ciphertext c is c = m [ e] mod n \u2022 Decryption Given c , the plaintext c is m = c [d ] mod n public key \u27e8 n , e \u27e9 decryption key \u27e8 n , d \u27e9 Encryption, Decryption private key d",
  "16": "RSA plaintext m public key n, e Private/decryption key n, d encryption decryption m c ciphertext difficult to derive private key from public key m [e] mod n c [d] mod n d = e [-] [1] mod \u0424 ( n ), i.e. de = 1 mod \u0424 ( n ) n = pq \u0424 ( n ) =(p-1)(q-1) Optional remark:   Consider the relationship: c = m [e] mod n \u2022 (RSA problem) Given c, n, e,     find m,    (called the e-th root of c) \u2022 (discrete log problem): Given c, n, m,    find e,     (called the discrete log of c)",
  "17": "Correctness of RSA \u2022 Note that for any positive m <n,    and any pair of public/private keys, Decrypt (Encrypt (m) ) = m That is, ( m [e] ) [d] mod n = m Optional Proof (sketch):  The correctness depends on this property of modulo: For any m, r, n, we have m [r] mod n =  m [ r  mod \u0424(] [n] [) ] mod n (when n is product of two primes, p,q,  then \u0424( n ) = (p-1)(q-1).) Now,  combining the fact that de mod   ( p -1)( q -1) = 1, we have m [de] mod n = m [1] mod n = m 17",
  "18": "Example \u2022 p=5, q=11,  n=55 \u2022 (p-1)(q-1) =  40 \u2022 Suppose     e = 3,    then d = 27 note that indeed      3\u00d727 mod 40 =  81 mod 40  = 1 \u2022 Suppose    m = 9 Encrypt: c=   m [e] mod n =   9 [3] mod 55 = 14 Decrypt c [d ] mod n = 14 [27] mod 55 = 14 [8\u00d72 + 8 + 3 ] mod 55 =  (36\u00d716\u00d749)  mod 55 = 9 18 There is an efficient algorithm that computes modulo exponentiation. Details omitted. There is an efficient algorithm that computes d from p, q, e. Details omitted.",
  "19": "Algorithmic issues \u2022 (Encryption/decryption)  There is an efficient algo to compute exponentiation. Hence, there is an efficient encryption algorithm: given n , m , e ,  compute m [e] mod n, and an efficient decryption algorithm: given c , d , n , compute c [d] mod n (To get additional speedup, choose a small e so that  encryption can be done very fast. It turns out that the value of e won\u2019t affect the security. But it can\u2019t be too small due to some attacks.  It is common to fixed e =65537. In such cases, e is not a secret.) \u2022 (step 1 in setup: Primality test) How to find a random prime?  Here is a correct and secure method: 1.Randomly and uniformly picks a number Randomly and uniformly picks a number p 2.If If p is a prime, outputs p and halts.  Otherwise, repeats 1-2. Since there are many primes*, the probability that the a randomly chosen integer is prime is high.  There is fast algorithm to determine whether a number is a prime. \u2022 (step 3 in setup) The value of d can be efficiently computed from e and n using the extended Euclidean algorithm. \u2022 Using Chinese Reminder Theorem, one can speedup decryption about x2 faster. \u2022 Public key doesn\u2019t need to be large (but not too small).  To achieve further speedup in encryption, it is common to choose a fixed small fixed public key such as 65537, which is 2 [16 ] - 1. *: (optional) This is by the well-known \u201cPrime Number Theorem\u201d. Probability of a randomly chosen 1024-bit number being a prime is around  ln(2 [1024] )~ (1/710).   So likely takes about 710 trials to get a 1024-bit prime number.   Fast but too slow for real-time application.  A well-know vulnerable algorithm, instead of uniformly pick the numbers, employ a faster but unfortunately insecure algorithm to find primes (ROCA: Return Of the Coppersmith Attack.   https://en.wikipedia.org/wiki/ROCA_vulnerability ) https://en.wikipedia.org/wiki/ROCA_vulnerability ) )",
  "20": "Interchangeable role of encryption and decryption key in RSA (but may not in others) \u2022 Textbook RSA has this property:   we can also use the decryption key d to encrypt, and then the encryption key e to decrypt.   In other words, we can swap the role of d and e , so that anyone in the public can decrypt, but only the owner can encrypt. \u2022 The above property is something special about RSA.  It usually does not hold in other public key schemes. For e.g. the ElGamal PKC doesn\u2019t has this property.   This property is useful in designing signature scheme. Caution:  Some documents flip encryption/decryption when describing RSA, i.e. using public key to decrypt, and private key to encrypt.  This can be very confusing. The root of this inconsistencies is due to how we use RSA in a signature scheme.  In RSA-based signature, the decryption key is the public key. 20",
  "21": "Other PKC Schemes: Discrete log-based PKC \u2022 ElGamal   Encryption ElGamal is a \u201cDiscrete Log-based\u201d encryption, whereas RSA is \u201cfactorization-based\u201d. There are many choices of Algebraic groups for discrete log-based encryption, e.g. Elliptic Curve. Those using Elliptic Cure are often called Elliptic Curve Cryptography (ECC).   Certain choices of ECC reduce the key size.   E.g. ~300 bit for equivalent of 2048-bit RSA. \u2022 Paillier Encryption Paillier Encryption is discrete-log based. optional remark: - Paillier is homomorphic w.r.t. addition. - ElGamal can be easily modified to be homomorphic w.r.t. multiplication. Post-quantum crypto. \u2022 See slides on post-quantum. 21",
  "22": "3.1.2 Security of RSA 22",
  "23": "Security of RSA \u2022 It can be shown that, the problem of  getting the RSA private key from public key  is as difficult as the problem of factorizing n. \u2022 However, it not known whether the problem of getting the plaintext from the ciphertext  is as difficult as factorization. 23 Factorization Finding the private key Finding the plaintext",
  "24": "State-of-the-art on factorization \u2022 more info:   http://en.wikipedia.org/wiki/Integer_factorization \u2022 A 640 bits number was successfully factored on Nov 2, 2005,  using approximately 30  2.2GHz- 640 bits number was successfully factored on Nov 2, 2005,  using approximately 30  2.2GHz- bits number was successfully factored on Nov 2, 2005,  using approximately 30  2.2GHz- Opteron-CPU years.   It is computed over five months using multiple machines. \u2022 A 768 bits number  (RSA-768) was factored in Dec 2009, using hundreds of machines over 2 768 bits number  (RSA-768) was factored in Dec 2009, using hundreds of machines over 2 bits number  (RSA-768) was factored in Dec 2009, using hundreds of machines over 2 years. \u2022 See https://en.wikipedia.org/wiki/RSA_Factoring_Challenge for latest status.  (829 bits in 2020.) https://en.wikipedia.org/wiki/RSA_Factoring_Challenge for latest status.  (829 bits in 2020.) for latest status.  (829 bits in 2020.) Recap NIST recommendation in  Topic 1. http://www.keylength.com/en/4/ ://www.keylength.com/en/4/",
  "25": "\u2022 Here is the 640-bits number 31074182404900437213507500358885679300373460228427275457201619488232064405180815 04556346829671723286782437916272838033415471073108501919548529007337724822783525 742386454014691736602477652346609 = 16347336458092538484431338838650908598417836700330923121811108523893331001045081 51212118167511579 * 19008712816648221131268515739354139754718967899685154936666385390880271038021044 98957191261465571",
  "26": "\u2022 Here is the 768-bits number 123018668453011775513049495838496272077285356959533479219732245215172640050726365751874 520219978646938995647494277406384592519255732630345373154826850791702612214291346167042 9214311602221240479274737794080665351419597459856902143413 = 347807169895689878604416984821269081770479498371376856891243138898288379387800228761471 1652531743087737814467999489 * 367460436667995904282446337996279526322791581643430876426760322838157396665112792333734 17143396810270092798736308917 from T Kleinjung et al., Factorization of a 768 - bit RSA modulus, eprint 2010. , eprint 2010. https://eprint.iacr.org/2010/006.pdf",
  "27": "post-Quantum cryptography \u2022 A Quantum computer can factorize and perform \u201c discrete log \u201d in polynomial time. In 2001, a 7- qubits quantum computer was built to factor 15, carried out by IBM using NMR. http://domino.watson.ibm.com/comm/pr.nsf/pages/news.20011219_quantum.html Hence, both RSA and \u201cdiscrete log based\u201d PKC will be broken with   Quantum computer. Post-Quantum Cryptography: This refers to cryptography that are secure against quantum computer. \u2022 Code base: Base on difficulty in decoding error correcting code. \u2022 Lattice-based cryptography:       Based on this hard problem--   Given the \u201cbasis\u201d of lattice, it is computationally hard to find the Based on this hard problem--   Given the \u201cbasis\u201d of lattice, it is computationally hard to find the shortest (or approx)  lattice point.  Most promising approach. \u2022 Multivariate polynomial:   Given a multivariate polynomial, it is difficult to find the solution (under modulo p). Given a multivariate polynomial, it is difficult to find the solution (under modulo p). Although currently we don\u2019t have quantum computer with sufficient \u201cqubits\u201d to break ~1000 bit RSA,  the threat of having such computer in near future is not negligible while the damage would be catastrophic.  Hence, there are significate efforts to migrate current systems to post-quantum crypto.  NIST is choosing a standard.   The process started in 2016. On July 5, 2022, NIST announced the first group of winners (  see https://en.wikipedia.org/wiki/NIST_Post-Quantum_Cryptography_Standardization    details of the algo not required. details of the algo not required. Just be aware of the NIST standardization process.)  More winners would be added to the standard. There were 50 submissions for round 1. 27",
  "28": "Padding of RSA \u2022 Same as symmetric-key encryption, some forms of IV is required  so that encryption of the same plaintext at different times would give different ciphertexts. Hence additional padding are required for security. \u2022 Textbook RSA has an interesting \u201chomomorphic\u201d property. These properties are useful in applications (e.g. blind signature, encrypted domain processing), but they also lead to attacks.   Such properties can be , but they also lead to attacks.   Such properties can be destroyed using padding. \u2022 The standard (Public-Key Cryptography Standards) PKCS#1, add \u201coptimal padding\u201d.  Details omitted. http://en.wikipedia.org/wiki/PKCS_1 ://en.wikipedia.org/wiki/PKCS_1 28",
  "29": "Pitfall:  (CWE-780) Using Texbook RSA https://cwe.mitre.org/data/definitions/780.html 29",
  "30": "3.1.3.  Efficiency 30",
  "31": "PKC is computationally expensive \u2022 Following NIST recommendation, 128-bit AES and 3072-bit RSA has the equivalent key strength. \u2022 RSA encryption/decryption is significantly slower than AES. \u2022 See Crypto++ Benchmarks                        (crypto++ is a C++ library) https://www.cryptopp.com/benchmarks.html 31 In different order of magnitude.",
  "32": "How to efficiently encrypt using public key? \u2022 If we want to encrypt a large file F, say a 7GB movie, it would be very slow to directly apply RSA (or other PKC) on F. \u2022 To encrypt a large plaintext using PKC, it is typically carried out in this way: 1. Chooses a random AES  key k; 2. Encrypts k using PKC to get y; 3. Encrypts F using AES (with suitable mode, say GCM, CBC or CTR) with k as the key to get C . 4. Output the ( y , C )  as the ciphertext. \u2022 To decrypt, 1. Decrypts y to get k using the PKC private key; 2. Decrypts C using k to get F . 32 Encrypt Randomly chosen an AES key k PKC public key Large Plaintext F AES encryption C y ciphertext Decrypt AES key k AES encryption PKC decryption key",
  "33": "3.2.  Data Authenticity (digest), unkeyed We follow Kerckhoff\u2019s principle.   Adversary knows all the algorithms. 33",
  "34": "Hash (no secret involved!!  Adversary knows the algo!!) A (cryptographic) hash is a function that takes an arbitrary large message as input, and outputs a fixed size (say 160 bits) digest . Security requirement (collision-resistant) : \u2022 It is difficult for an attacker to find two different messages  m1 , m2  that \u201chash\u201d to the same digest. 1 , m2  that \u201chash\u201d to the same digest. , m2  that \u201chash\u201d to the same digest. 2  that \u201chash\u201d to the same digest. that \u201chash\u201d to the same digest. That is, h( m 1) = h( ) = h( m 2) ) This is known as collision-resistant . [*] *: (optional) Formal security formulation of hash turns out to be complicated. A formal definition of  collision resistant consists of a randomly chosen key which is made public after chosen. Another formulation uses \u201dRandom Oracle\u201d which is convenient but not realizable. Attend higher-level of crypto course for more. 34 1010010....01111001 Hash 101101011 fixed size digest arbitrary long message",
  "35": "Security requirement of hash \u2022 Collision Find two different messages  m1 , m2   s.t. 1 , m2   s.t. , m2   s.t. 2   s.t. s.t. h( m 1) = h( ) = h( m 2) ) \u2022 2 [nd] pre-image Given m1 ,   find  m2  s.t. 1 ,   find  m2  s.t. ,   find  m2  s.t. 2  s.t. s.t. h( m 1) = h( ) = h( m 2) ) \u2022 Pre-image Given y ,   find m s.t. h( m ) = y 35 Threat model: Collision-Resistant Second pre-image-Resistant One-way Security requirement m1 1 m 2 h",
  "36": "Example of hash algorithms that are not collision resistant \u2022 Taking selected bits from the data. \u2022 CRC checksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check https://en.wikipedia.org/wiki/Cyclic_redundancy_check 36",
  "37": "Popular Hash \u2022 SHA-0,  SHA-1, SHA-2, SHA-3 \u2022 SHA-0 was published by NIST in 1993. It produces a 160-bits digest. It was withdrawn shortly after publication and superseded by the revised version SHA-1 in 1995. \u2022 SHA-1 is a popular standard. It produces 160-bits message digest.  It is employed in SSL, SSH, etc. \u2022 In 1998,  an attack that finds  collision of SHA-0 in 2 [61 ] operations was discovered.  (Using the straight forward birthday attack, collision can be found in 2 [160/2] = 2 [80] operations).   In 2004, a collision was found, using 80,000 CPU hours.  In 2005,  Wang Xiaoyun et al. (Shandong University) gave attack that can finds collision in 2 [39] operations. \u2022 In 2001, NIST published SHA-224, SHA-256, SHA-384, SHA-512, collectively known as SHA-2.  The number in the name indicates the digest length.  No known attack on full SHA-2 but there are known attacks on \u201cpartial\u201d SHA-2, for e.g. attack on a 41-rounds  SHA-256 (the full SHA-256 takes 64 rounds) \u2022 In 2005, Xiaoyun Wang et al gave a  method of finding collision of SHA-1 using 2 [69 ] operations, which was later improved to 2 [63] .    A collision was found in 2017. It took 110 GPU years,  completed 2 [63] SHA1 operations. https://security.googleblog.com/2017/02/announcing- https://security.googleblog.com/2017/02/announcing- first-sha1-collision.html \u2022 In Nov 2007, NIST called for proposal of SHA-3. In Oct 2012, NIST announced the winner, Keccak (pronounced \u201ccatch-ack\u201d). ( NIST announcement http://www.nist.gov/itl/csd/sha-100212.cfm ) 37",
  "38": "Recent Successful Collision Attacks on SHA-1 (Feb 2017) 38 SHAttered ttered (shattered.io) Feb 23, 2017",
  "39": "Successful Collision Attacks on SHA-1 (Feb 2017) 39 \u2022 Done by a team from CWI and Google \u2022 Two PDF files with the same hash values as proof of concept: - https://shattered.io/static/shattered-1.pdf - https://shattered.io/static/shattered-2.pdf \u2022 Defense mechanisms: - Use SHA-256 or SHA-3 as replacement see https://shattered.io/",
  "40": "\u2022 MD5 \u2022 Designed by Rivest.  MD, MD2, MD3, MD4, MD5, MD6. \u2022 MD6 was submitted to NIST SHA-3 competition but did not advance to the second round of the competition. \u2022 MD5 was widely used. It produces 128-bit digest. \u2022 In 1996, Dobbertin announced a collision of the compress function of MD5. \u2022 In 2004, collision was announced by  Xiaoyu Wang et al. The attack was reported to take one hour. \u2022 In 2006, Klima give an algorithm that can find collision within one minute on a single notebook. 40",
  "41": "An application scenario of unkeyed Hash (without secret keys) 41",
  "42": "Application of (unkeyed) Hash for integrity Consider this example \u2022 Alice downloaded a software vlc-2.2.8-win32.exe from the web. Is the downloaded file authentic? (see the \u201cchecksum\u201d  in next slide) Specifically, 1. Alice visits the website of VLC. 2. Since the website is hosted with HTTPS  protocol, Alice is being assured that the content displayed on the browser is from VLC and authentic. We will discuss https later and right now, let\u2019s treat all info displayed by browser as authentic. 3. However, the downloading site is a 3rd-party, i.e. the actual file vlc-2.2.8-win32.exe is hosted in another website.  The communication channel to the 3 [rd] party website is not secure. There is also a possibility that the 3 [rd] party website is malicious and giving out virus infested software. 4. To verify that the file indeed is the original, after Alice downloaded the file, she can check the integrity of the file by matching the \u201chash\u201d of the file  with the \u201cSHA-256 checksum\u201d displayed in the browser.  If they match, then Alice is very sure that the file is intact.  If not, certainly the file is corrupted. 42",
  "43": "43 the digest (aka checksum). https.   So the content displayed here is from videolan.org and is authentic. Question:  why  \u201dvideolan.org\u201d in the url is boldfaced? (help the user to identify the domain name, so that the user is less likely to fall prey to phishing attack.) Actual file is hosted in a third-party site Although the information displayed in the browser is verified to be authentic, what about information from the third-party site? Ads from 3 [rd] party. (might not via https and videoland.org  is unable to control what being shown)",
  "44": "Application of (unkeyed) Hash for integrity In this scenario, we assume that there is a secure channel to send short piece of information. (in VLC example, this channel is the https) Let F be the original data.  Alice obtains the digest h( F ) from the secure channel. Alice obtains a file, say F\u2019 , whose origin claims that the file is F.  Alice computes and compares the digests  h( F ), h( F \u2019). If they are the same, F\u2019 is indeed same as F with very high confidence.  If they are different, then F\u2019 must be different from F, i.e. integrity compromised. h( F ) = h( F\u2019 ) \u21d2 with high probability, F = F\u2019 h( F ) \u29e7 h( F\u2019 ) \u21d2 F \u29e7 F\u2019 44",
  "45": "(unkeyed) hash F h(F) Hash F\u2019 h(F) Hash h(F\u2019) Compare: h(F)=h(F\u2019)? Yes (F is likely the same as F\u2019) No (F is different from F\u2019) unsecure channel secure channel Verification",
  "46": "(unkeyed) hash F h(F) Hash F\u2019 h(F) Hash h(F\u2019) Compare: h(F)=h(F\u2019)? Yes (F is likely the same as F\u2019) No (F is different from F\u2019) unsecure channel secure channel Verification The original VLC.exe File downloaded by Alice digest of authentic VLC.exe digest Alice obtained from trusted source",
  "47": "Similar setup in many other download sites.. 47 Downloading Window 10. instruction/explanation from Microsoft https with padlock. So, content  (other than 3 [rd] party) displayed here are verified to be from an entity registered as  microsoft.com with a \u201cCertificate Authority\u201d trusted by the browser, assuming that the running environment and  browser is authentic. In other words, assuming no malware in computer, the fact that we have a padlock assure us that info displayed is from microsoft.com This course would cover the details in the above statement. The hashed value.",
  "48": "Security Requirement. \u2022 What would an attacker do? - attacker\u2019s goal:  makes Alice accepts a file other than F. - Attacker knows F and can send any file F\u2019  over.    To trick the user, the attacker need to have a F\u2019 s.t. H(F\u2019)= H(F) and F\u2019 \u2260 F. The above is an example of 2 [nd] preimage : In practical applications, for the attack to make sense, the attacker might need to find a F\u2019 that meet certain properties.  For e.g. F\u2019 should be a workable malware.   From the defender\u2019s point of view, we want to cover as many possible attacks as possible.  Hence, we focus on the modest (easiest) goal of finding any F (not necessary meeting the property), i.e. the 2 [nd] preimage problem. Is there  a problem easier than 2 [nd] preimage problem?  Yes. \u201cCollision\u201d. 48",
  "49": "3.3 Data Origin Authenticity  (mac),  Keyed 49",
  "50": "Recap:  Hash (no secret involved) (no secret involved) Security requirement (collision) : \u2022 ( Collision-resistant ) It is difficult for an attacker to find two different messages  m1 , m2  that \u201chash\u201d to the same digest.  That is, 1 , m2  that \u201chash\u201d to the same digest.  That is, , m2  that \u201chash\u201d to the same digest.  That is, 2  that \u201chash\u201d to the same digest.  That is, that \u201chash\u201d to the same digest.  That is, h(m1) = h(m2) 1) = h(m2) ) = h(m2) 2) ) 50 1010010....01111001 Hash 101101011 fixed size digest arbitrary long message",
  "51": "Keyed-Hash (aka MAC)   (a secret key is involved) (a secret key is involved) A keyed-hash is a function that takes an arbitrary large message and a secret key as input, and outputs a fixed size (say 160 bits) mac (message authentication code) . \u2022 Security requirement (forgery) forgery) ) :  After seen multiple valid pairs of  messages and their corresponding  mac, it is still difficult for the attacker to forge the mac of a message not seen before. 51 1010010....01111001 MAC 101101011 fixed size mac arbitrary long message key",
  "52": "Popular  keyed-hash  (MAC) \u2022 CBC-MAC       (based on AES operated under CBC mode) \u2022 HMAC             (based on SHA) Hashed-based MAC standard:   RFC 2104. http://tools.ietf.org/html/rfc2104 52",
  "53": "CBC-mac 53 e k e k e k e k Initial value (IV) X1 1 X2 2 X3 3 X4 4 0 mac",
  "54": "HMAC HMACk (x) = k (x) = (x) = = SHA-1 ( ( K \u2295 opad ) || SHA-1 ( ( K \u2295 ipad ) ||  x)  ) where opad = 3636\u202636 (outer pad) ipad = 5c5c\u20265c             (inner pad) (inner pad) (the above are in hexadecimal) 54",
  "55": "An application scenario for mac 55",
  "56": "\u2022 In the previous example (on vlc), we assume that there is a secure channel to send the digest. \u2022 There are scenarios where we don\u2019t  have a secure channel to deliver the digest.  (in There are scenarios where we don\u2019t  have a secure channel to deliver the digest.  (in (in the vlc example, it relies on the fact that we have https.  What if we don\u2019t have https?) \u2022 In such scenarios, we can protect the digest with the help of some secrets. - In the symmetric key setting,  it is called the mac. - In the public key setting,  it is called the digital signature. 56",
  "57": "mac (Message Authentication Code) Note: Unlike the example on hash, the mac could be modified by attacker. F mack (F) k (F) (F) Mac F\u2019 mac k t\u2019 Compare: t == mack(F\u2019)? k(F\u2019)? (F\u2019)? Yes (F is likely to be from someone who knows the key k) No (something being modified, either F\u2019, t or both) unsecure channel unsecure channel key k Verify t Security Requirement (forgery) : After seen multiple valid pairs of  messages and their corresponding  mac, it is still difficult for the attacker to forge the mac of a message not seen before. attacker can inject F\u2019 and t\u2019",
  "58": "Remark \u2022 Consider an attacker who saw F and mac(F).  The attacker wants to find a F\u2019 and t\u2019 that are valid. Recap that we want a method that can protect against attacker with strong capability.   Hence, in the security requirement,  we consider a threat model where the attacker have accesses to many pairs of message and mac: ( m1, mac(m1)  ),  (m2, mac(m2)), \u2026.. 1, mac(m1)  ),  (m2, mac(m2)), \u2026.. , mac(m1)  ),  (m2, mac(m2)), \u2026.. 1)  ),  (m2, mac(m2)), \u2026.. )  ),  (m2, mac(m2)), \u2026.. 2, mac(m2)), \u2026.. , mac(m2)), \u2026.. 2)), \u2026.. )), \u2026.. The attacker goal is to find a valid (m\u2019, t\u2019), where m\u2019 is not one of the mi i . \u2022 Note that there is no issue on confidentiality.  In fact, the data F can be sent in clear. \u2022 Typically, the mac is appended to F. Hence, mac is also called the authentication tag, or authentication code. 58 F mac",
  "59": "3.4  Data Origin Authenticity  (Signature), Asymmetric key 59",
  "60": "Signature \u2022 The public key version of MAC is called Signature. \u2022 Here, the owner uses the private key to generate the signature.    The public can use the public key to verify the signature. \u2022 So,  anyone can  verify the authenticity of the data, but only the person who know the private key can generate the signature. 60",
  "61": "Signature Verifier and Signer using different key. F signature s Sign F\u2019 verify Yes (F is likely to be from someone who knows the corresponding private key) No (something being modified, either F\u2019, s\u2019 or both) unsecure channel unsecure channel kpri pri s\u2019 kpub pub kpri:    private key pri:    private key :    private key kpub:   public key pub:   public key :   public key Security Requirement : After seen multiple valid pairs of  messages and their corresponding signature, it is still difficult for the attacker to forge the signature of a message not seen before.  Attacker knows the public key.",
  "62": "Remark \u2022 Likewise, the computed signature is typically appended to F. \u2022 When we say that \u201c Alice signs the file F \u201d , we mean that Alice computes the signature s, and then appends it to F. \u2022 Later, the authenticity of F can be verified by anyone who knows the public key. The valid signature can only be computed by someone who knows the private key. So, if it is valid, then F must be authentic. \u2022 Anyone can verify the signature using the public key. 62 F s",
  "63": "What so special of signature compared to mac? \u2022 Public key has the advantage that we only need a secure broadcast channel to distribute the key. \u2022 Beside the above, signature achieves additional security requirements. \u2022 We can view the digital signature as handwritten signature in legal document.    A legal document is authentic if it has the correct handwritten signature.  No one, except the authentic signer, can generate the signature.  Hence, the signer cannot repudiate, ie. deny having signed the document. \u2022 Signature scheme achieves Non-repudiation. Non-Repudiation :  Assurance that someone cannot deny previous commitments or actions. 63",
  "64": "Example on non-repudiation \u2022 (using mac).  Suppose Alice sent Bob a message appended with a mac. The mac is computed with a key shared by Alice and Bob.     Later Alice denied that she had sent the message. When confronted by Bob, Alice claimed that Bob generated the mac. \u2022 (using signature).  Suppose Alice sent Bob a message, signed using her private key. Later, she wanted to deny  that she had sent the message.  However, she was unable to so.  This is because only the person who knows the private key can sign the message and  only Alice knows the private key.  Hence, the signature is a proof that Alice generated the message. 64",
  "65": "Popular Signature scheme \u2022 A popular group of schemes use RSA for the sign/verify component. : RSASSA-PSS, RSASSA-PKCS1:   signature scheme based on RSA \u2022 DSA (Digital Signature Algorithm) is another popular standard whose security depends on discrete log. https://en.wikipedia.org/wiki/Digital_Signature_Algorithm#Implementations 65",
  "66": "Design of Signature scheme \u2022 Signature schemes typically consist of two components. An unkeyed hash,  and the sign/verify algorithm. 66 Hash e.g. SHA3 X h Sign Private key s Hash e.g. SHA3 X h s verify Yes/No Verification of signature Generation of signature Arbitrary large Fixed size, e.g. 256 bits Fixed size, e.g. 512 bits Public key",
  "67": "RSA-based signature \u2022 Use RSA for signing and verification.   Essentially, the signature is the \u201cencrypted\u201d digest. During verification,  decrypt to obtain the digest and compare. A messy notation issue:  Previously, we use public key to encrypt.  Here, we use private key to encrypt.  Recall that for RSA, we can flip the role. . s =  RSA_enc ( \u27e8 private key, public key \u27e9 ,   Hash(X) ) \u2022 Verification  of (X, s ) is done by using the public key . If  Hash (X) = RSA_dec (public key,  s)   then accept, else reject. 67 Hash e.g. SHA3 X h RSA encrypt \u27e8 Private key, public key \u27e9 s Hash e.g. SHA3 X h RSA decrypt Public key s compare Yes/No",
  "68": "Not necessary to have \u201cencryption\u201d in signature scheme \u2022 We employ Hash-and-Encrypt  on RSA to obtain signature.  Note that Hash-and-Encrypt is a special way to obtain signatures.  Not all signature scheme use Hash-and-Encrypt.    Also recap that RSA has a property that encrypt/decrypt can be flip. \u2022 Popular schemes such as DSA do not \u201cencrypt\u201d. \u2022 Many books/documents describe a signature as the encryption of the hash and call all methods \u201chash-and-encrypt\u201d.  IMHO,  this description is wrong.   (due to the above point.) \u2022 A more accurate term would be:  \u201chash-and-sign\u201d 68",
  "69": "Summary 69",
  "70": "Digest (Hash) The digest must be sent through secure channel F h Hash F\u2019 verify Yes (F is likely same as  F) No (F\u2019 is being modified) unsecure channel secure channel h Security Requirement :  Different to find a pair F, F\u2019 with the same digest",
  "71": "MAC (Message Authentication Code) The mac can be sent through an unsecure channel.  Both F mac Sign F\u2019 verify Yes (F is likely to be from someone who knows the corresponding private key) No (something being modified, either F\u2019, mac\u2019 or both) unsecure channel unsecure channel mac\u2019 k Security Requirement :  Without knowing k , even after seen many pairs of  messages and their valid mac, it is difficult to forge a mac for message not seen before.",
  "72": "Signature Verifier and Signer using different key. F signature s Sign F\u2019 verify Yes (F is likely to be from someone who knows the corresponding private key) No (something being modified, either F\u2019, s\u2019 or both) unsecure channel unsecure channel kpri pri s\u2019 kpub pub kpri:    private key pri:    private key :    private key kpub:   public key pub:   public key :   public key Security Requirement :  Without knowing the private kpri, even after seen many pairs of  messages pri, even after seen many pairs of  messages , even after seen many pairs of  messages and their valid signatures, it is difficult to forge a signature for message not seen before.",
  "73": "3.5.  Some attacks and pitfalls 73",
  "74": "3.5.1 Birthday attacks This attack is like \u201cexhaustive search\u201d in encryption.  Birthday attack can be applied to all hash functions, similar to exhaustive search on all encryption  schemes. We want to design a hash so that known attacks can\u2019t do better than birthday attack. This attack illustrates why 256-bit digest is required for hash, when 128-bit encryption is considered sufficient for encryption. 74",
  "75": "\u2022 Hashes are designed to make  collision difficult to find. Recall that a collision consists of two different messages x1, x2 that give the same digest, i.e. 1, x2 that give the same digest, i.e. , x2 that give the same digest, i.e. 2 that give the same digest, i.e. that give the same digest, i.e. h(x1) = h(x2)   and x1 1) = h(x2)   and x1 ) = h(x2)   and x1 2)   and x1 )   and x1 1 \u29e7 x 2 \u2022 Any hash function is subjected to birthday attack .  (similar to exhaustive search on encryption scheme). 75",
  "76": "A straightforward method to find collision Suppose H() is a hash with  k-bit digest. Find collision: 1. Randomly pick two messages m1, m2 1, m2 , m2 2 . 2. If H(m1) = H(m2),  then output m1, m2 1) = H(m2),  then output m1, m2 ) = H(m2),  then output m1, m2 2),  then output m1, m2 ),  then output m1, m2 1, m2 , m2 2 and halt. 3. Repeat 1 to 3. The expected number of rounds taken by the above algorithm is 2 [k  ] and  thus the expected number of hashes is more than 2 [k] .  If k =128,  as analyzed in tutorial one, this is computationally infeasible.  But \u2026.. Why? Every round would have  probability of 2 [-k] to halt.   Let X to be the number of rounds the algorithm takes. This is \u201cGeometric Distribution\u201d with parameter p=2 [-k.] The expected number of rounds is 1/p, which is 2 [k.] 76",
  "77": "Birthday attack Suppose H() is a hash giving k-bit digest. 1. Constructs a set S of  M= \u23a1 1.17* 2 [k/2] \u23a4 unique randomly chosen messages. 2. Compute the digest of each message m in S. 3. Check whether there are two messages in S having the same digest.  If so, output m 1, , m 2 .  Otherwise, output \u201cFail\u201d. .  Otherwise, output \u201cFail\u201d. 77 \u2026 m 3 m 4 m 1 m 2 H() When k=128,  one round would take ~ 2 [64    ] hashes, significantly lower than before.  Next few slides show that with high probability, the above succeeds.",
  "78": "Birthday attack \u2022 Suppose we have  M messages, and each message is tagged with a value randomly chosen from {1,2,3,\u2026,T}. \u2022 The probability that there is a pair of messages tagged with the same value is approx.: Prob( collision )  \u2248  1- exp (- M [2] / (2T)) \u2022 In particular,  when M > 1.17   T [0.5] then,   Prob (Collision ) >  1-exp ( 1.17/2 ) >  0.5. 78 message1 1 message2 2 messageM M \u2026 1 2 3 T \u2026 In a class of 25 students, with probability more than 0.5, there is a pair of students having the same birthday. Relate to Hash & Birthday attack: \u2022 Suppose the hash gives 128-bit digest. \u2022 Then T = 2 [128] \u2022 By choosing  M = 1.17 2 [64] , with probability more than 0.5, birthday attack succeed.",
  "79": "Remark Recommended digest length \u2022 Recap the NIST key-length recommendation ( http://www.keylength.com/en/4/ ) http://www.keylength.com/en/4/ ) ) \u2022 When key length for symmetric-key is 112,  the corresponding recommended length for digest is 224.   Why the digest  length is twice larger? (birthday attack) (optional: If you like CS3230, take a look ) Improved birthday attack with constant memory \u2022 Birthday attack needs large memory to store the digests.  Interestingly, using Cycle Detection , only constant size memory is required. https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare 79",
  "80": "3.5.2 Common pitfall: Using encryption for an application that needs authentication 80",
  "81": "The mobile phone and a server share a secret 256-bit key k. The server can send instructions to the mobile phone via sms. (Note that sms only consist of readable ascii  characters.  We assume that there is a way to encode binary string using the readable characters). The format of the instruction The format of the instruction he format of the instruction is: X   P where X is an 8-bit string specifying the operation, and P is a 120-bit string specifying the parameter. So, an instruction is of size 128 bits.  If an operation doesn\u2019t need a  parameter, P will be ignored.    There is a total of  15 valid instructions. E.g. 00000000  P :  send the GPS location to phone number P via sms.  If P is not a valid phone number, ignore. 11110000  P :  rings for  P seconds.  If P>10,  ignore. 10101010     :  self-destruct now! 81 Encryption schemes may provide false sense of security.  Consider this design of a mobile apps from a company  XYZ.",
  "82": "\u2022 An instruction is to be encrypted using AES CBC-mode with 256-bit key,  encoded to readable characters and sent as sms.   (recap: block size of AES is 128 bits). \u2022 After a mobile phone received a sms, it decrypts it. If the instruction is invalid, it ignores the instruction. Otherwise, it executes the instruction. \u2022 The company XYZ claims that \u201c 256-bit AES provides high level of security, and in fact is classified as Type 1 by NSA.  Hence the communication is secure. Even if the attackers have compromised the base station, they are still unable to break the security \u201d. \u2022 Something is wrong here. (If an attacker sends a randomly chosen message to the mobile phone,  what is the probability that the mobile phone self- destruct?) 82",
  "83": "Remarks \u2022 Encryption is designed to provide confidentiality.  It does not necessary guarantee integrity and authenticity. \u2022 In the previous example,  XYZ wants to achieve \u201cauthenticity\u201d, but wrongly employed encryption to achieve that.  (Some encryption schemes also provide authenticity, but not all.) (Some encryption schemes also provide authenticity, but not all.) \u2022 A secure design should use schemes for authenticity instead of encryption. \u2022 Furthermore, this application requires \u201ccommunication authenticity\u201d, not just \u201cdata-origin authenticity\u201d. 83"
}