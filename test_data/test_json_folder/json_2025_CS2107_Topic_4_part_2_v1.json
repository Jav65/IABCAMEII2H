{
  "1": "Topic 4: PKI + Channel Security Part 1: PKI (seems easy but lots of implementation issues) 4.1  Distribution (broadcasting) of public keys 4.2  PKI 4.2.1  Certificate 4.2.2   CA 4.3  Limitations/attacks on PKI Part 2: Channel Security 4.4  Protocol 1: Authentication 4.5  Protocol 2: Key Exchange 4.6  Protocol 3: Authenticated Key Exchange 4.7  Putting all together: Securing Communication Channel 4.8 Forward Secrecy Change Log (v1): \u2022 Slide 1 (added 4.8 forward secrecy) \u2022 Added section 4.8 as the last few slides. \u2022 Slide 24, 25: Major changes.  Switching  the role of Alice and Bob Slide 25. Changing notations for consistency.",
  "2": "Part II:  Channel Security 4.4 Authentication Protocols 3 subtly different threat models with 3 different protocols. \u2022 Authentication \u2022 Key-exchange \u2022 Authenticated key-exchange 2 Main difference of data-origin authentication vs communication authentication: \u201c Freshness \u201d \u2022 A piece of authentic data remains authentic over time. In communication, we want to verify authenticity of the interacting entity at that point of time.",
  "3": "Summary & takeaways \u2022 Protocols:  (basic) Authentication, Key Exchange, Authenticated Key Exchange. - Authentication. Adversary extract information and later impersonate .  (Assuming each entity remains the same throughout each (Assuming each entity remains the same throughout each session).   Unilateral, Mutual. Unilateral, Mutual. - Key exchange: Adversary sniffs and wants to steal the session key . No authentication.  (PKC, DH) - Authenticated key exchange. Adversary is Mallory (can sniff, spoof, modify,  and thus can take over session) and wants to and wants to impersonate and/or steal the session key. \u2022 Putting all together.  With crypto primitives, we can obtain a secure (w.r.t. authenticity &  confidentiality,  and against Mallory) channel on top of an underlying  unsecure public channel. - Method: (1) Use long-term key in Authenticated key exchange to get a fresh session key (2) Use session key to protect confidentiality (encrypt)  & integrity (mac) of  subsequent messages via authenticated encryption . - Why not just using the long-term key in step (2)? \u2022 More efficient. \u2022 Forward secrecy. 3 Part 2: Channel security",
  "4": "Summary: (basic) Authentication 4 Threat model \u2022 Capability: can be man-in- the-middle during authentication \u2022 Goal: Impersonate Alice in step (2), i.e. trick Bob to accept. Alice Bob (1) Authentication protocol Bob decides whether the prover is authentic. (2) Using stolen info to impersonate Alice Mallory can sniff, modify Mallory Stolen info Prover Verifier note: step(1) & (3) cannot be carried out in parallel.",
  "5": "Summary: Key exchange 5 Alice Bob (1) Key exchange protocol (2) Outcome of key exchange is a common session key k (2) Outcome of key exchange is a common session key k (3) Communication protected by k via encryption Eve can only sniff Threat model \u2022 Capability: can only sniff. \u2022 Goal: Steal info on k. Step (3) is on subsequent usage of k.  It is not part of key- exchange. It is about confidentiality. Authenticity not considered.",
  "6": "Summary: Authenticated Key-Exchange 6 Alice Bob (1) Authenticated key exchange (in SSL/TLS, this is called handshake ) (2) Outcome of authenticated  key exchange is a common session key k (2) Outcome of authenticated  key exchange is a common session key k (3) Communication protected by k , via \u201cauthenticated encryption\u201d Mallory can sniff, modify Threat model \u2022 Capability: Can sniff, modify throughout the session. \u2022 Goal:  Impersonate A/B and/or steal k. Note: Authenticated Key Exchange is commonly called Handshake in many standards, e.g. TLS. In this course, to differentiate from non-secure handshake (e.g. TCP handshake), we use the term authenticated key-exchange. Step (3) is on subsequent usage of k.  It is not part of authenticated key-exchange.",
  "7": "(basic) Authentication  Protocol An entity wants to convince Bob that she is indeed Alice. The entity does so by convincing Bob that she knows some \u201csecrets\u201d. Attack model : attack-then-impersonate \u2022 Mallory can sniff and modify the communication between the authentic Alice and Bob. \u2022 Next, Mallory uses the stolen info to impersonate Alice. stolen info (1) Authentication protocol (2) Using stolen info to impersonate",
  "8": "Example of  insecure protocol Sending the authentication credential over is a simple but not secure protocol. Eve can simply \u201creplay\u201d to impersonate. 8 Alice Bob I\u2019m Alice, my password is \u201copensesame\u201d Eve Bob I\u2019m Alice, my password is \u201copensesame\u201d Eve Eavesdrops Replays Note: If the attacker can\u2019t sniff, it is ok to use the above simple method.",
  "9": "To prevent Replay:   Challenge-response Suppose Alice and Bob have a shared secret k, and both have agreed on a message authentication code.  An entity who knows k is either Alice or Bob.  Now, when an entity P wants to convince Bob  that she/he is Alice, the following is carried out: ( P refers to \u201cProver\u201d). (1) P sends to Bob a hello message \u201cI\u2019m Alice\u201d (2)   (Challenge) Bob randomly picks a message m and sends m to P . (3) (Response) P computes t = mack ( k ( ( m ). P sends t to Bob. (4) Bob verifies that the tag  received is indeed the mac of m .   If so, accepts,  otherwise rejects . 9 sketch of proof: Consider  an attacker who had sniffed many sessions between Alice and Bob and gathered many pairs of (m,t).  After that, the attacker wanted to use the gathered info to convince Bob.   Bob would send a challenge m\u2019 in step (2).  With very high probability,  m\u2019 was not sent before.  Now, by security of mac, the attacker couldn\u2019t derive the valid tag of m\u2019. Alice Bob (1) \u201cI\u2019m Alice\u201d (2) m k k (3) t = mack ( k ( ( m ).",
  "10": "\u2022 By property of mac, even if Eve has sniffed the communication between Alice and Bob, and has obtained multiple pairs of valid m , t ,   Eve still can\u2019t forge the mac for messages that Eve has not seen before. \u2022 Eve can\u2019t replay the response. This is because the challenge is randomly chosen and likely to be different in the next authentication session. The challenge m ensures freshness of the authentication process.  It is also known as the cryptographic nonce (or simply nonce ). \u2022 This protocol only authenticates Alice. That is, authenticity of Alice is verified. Hence it is called unilateral authentication. There are also protocols to verify both parties, which are called mutual authentication. 10",
  "11": "Unilateral authentication using PKC We can also have a public key version using signature. Suppose Bob wants to authenticate an entity P who claims to be Alice. (1) P notifies Bob. \u201c I\u2019m Alice\u201d.  Certificate attached if required. \u27e8 \u201cI\u2019m Alice\u201d,  certificate \u27e9 \u201cI\u2019m Alice\u201d,  certificate \u27e9 \u27e9 (2) (Challenge) Bob chooses a random message r and sends to P : \u27e8 \u201chere is your challenge\u201d, \u201chere is your challenge\u201d, r \u27e9 (3) (Response) P uses the private key to sign r . \u27e8sign( sign( r )\u27e9 \u27e9 (4) Bob verifies all info (certificate, signature). If valid, accept. 11 \u2022 If Bob already knows Alice\u2019s public key, the certificate can be omitted. \u2022 An attacker can observe multiple interactions between the authentic Alice and Bob. By security of signature, the attacker can\u2019t forge the response. \u2022 The nonce r ensure freshness. Alice Bob (1) \u201cI\u2019m Alice\u201d (2) r kpri , kpub pri , kpub , kpub pub k pub (3) s = sign ( r ).",
  "12": "We need to handle Mallory and securing subsequent interactions \u2022 The pervious security model assumes the attacker can only attack-and-impersonate. We can use it for applications like door access system: if authentic, door will open.   What if in the application, there are follow up communications after authentication? \u2022 For example, consider a Mallory in-between Alice and Bob.  That is, Mallory is the MITM.   Mallory wants to impersonate Alice. As per assumption, Mallory can sniff, spoof, and modify the message. Mallory first allows Alice and Bob to carry out the strong authentication.  After Bob is convinced that he is communicating with Alice, Mallory interrupts and takes over the channel. Later Mallory pretends to be Alice.  So, even if we employ the challenge-response in the previous slide, Mallory can still succeed in this setting. 12 Alice Bob Mallory",
  "13": "\u2022 To protect subsequent interactions, we can use authenticated key-exchange. The communication consists of two phases: - First phase is authentication key-exchange.  The outcome is a new shared secret k known as session key. - Subsequently, all communication will be protected (encrypted + mac)  using k. \u2022 To understand authentication key-exchange, we first look at another protocol  known as Key- exchange (or Key-agreement).  In Key exchange, there are two communicating entities Alice and Bob.  Alice and Bob want to establish a shared key between them. \u2022 Attack Model: - Eve can only sniff. - Eve\u2019s goal is to steal the established key. 13",
  "14": "4.5 Key-exchange Attack Model - Capability: Eve. - Goal: Steal session key. Two Methods:  PKC-based,  DH 14 Alice Bob (1) Key exchange protocol (2) Outcome of key exchange is a common session key k (2) Outcome of key exchange is a common session key k Eve can only sniff Threat model \u2022 Capability: can only sniff. \u2022 Goal: Steal info on k.",
  "15": "\u2022 Alice and Bob want to establish a common key. The established session key can be used to protect (e.g. via cipher, mac) subsequent communication  between Alice and Bob. \u2022 Threat Model.  We consider Eve. Capability:   Eve can only sniff the :   Eve can only sniff the communication. Goal:     Even want to steal info of the session Even want to steal info of the session ven want to steal info of the session key k. \u2022 Two methods:   PKC-based,  DH. 15 Alice Bob (1) Key exchange protocol (2) Outcome of key exchange is a common session key k (2) Outcome of key exchange is a common session key k Eve can only sniff Key-exchange    (Eve. No authentication) (Eve. No authentication)",
  "16": "PKC-based Key-exchange Here is a key-exchange that uses a PKC 1. Alice generates a pair of private/public key. 2. Alice sends the public key ke e to Bob. 3. Bob carries out the following i. Randomly chooses a secret k , ii. Encrypts k using ke e . iii. Sends the ciphertext c to Alice. 4. Alice uses her private key kd d to decrypt and obtain k. 16 Alice Bob (2) public key k e (3.i) Chooses a random secret k (3.ii) c =  Encrypt ( ke e , c ) (3.iii) c (4) k = Decrypt( kd d ,c) (1) generates ke e and kd d .",
  "17": "\u2022 Attacker (Eve) can obtain the public key k e and the ciphertext and the ciphertext c . \u2022 By security of PKC,  from the public key and ciphertext,  attacker can\u2019t get any information of the plaintext, which is the key k . 17",
  "18": "Diffie-Hellman key-exchange We assume both Alice and Bob have agreed on two public parameters,   a generator  g and a large (e.g. 1000 bits) prime p .   Both g and p are not secret and known to the public. 18 Alice Bob (2.1) x= g [a] mod p (3.1) \u2022 Compute k =  y [a] mod p (1.1) \u2022 Randomly chooses a \u2022 Compute x= g [a] mod p (2.2) y= g [b] mod p (3.2) \u2022 Compute k =  x [b] mod p (1.2) \u2022 Randomly chooses b \u2022 Compute y= g [b] mod p Security relies on the CDH assumption. Computational Diffie-Hellman CDH assumption : Given g , p , x= g [a] mod p, y= g [b] mod p, it is computationally infeasible to find k= g [ab] mod p . Remarks: 1. Step (1.1)&(1.2), (2.1)&(2.2), (3.1)&(3.2) can be carried out in parallel. 2. The assumption seems self-fulfilling. Nonetheless, there are many evidences that it holds. 3. The operation of \u201cexponentiation\u201d can be applied to any algebraic group, i.e. not necessary integers. CDH doesn\u2019t hold in certain groups. The crypto community actively searches for groups that CDH holds.  E.g.  Elliptic Curve Cryptography ECC is based on elliptic curve group where CDH believed to hold.",
  "19": "Eg. 19 Alice Bob (2.1)  x = g a mod p = 16 (3.1) Compute k =  y a mod p = 3 15 mod 23 = 12 (1.1) randomly chooses a = 15 (2.2)  y  = g b mod p = 3 (3.2) Compute k =  x b mod p = 16 8 mod 23 = 12 (1.2) randomly chooses b = 8 g = 2,        p = 23 From 16, and 3,  it is very difficult to get  12. (here, we are referring to very large, say 2000-bit integer) Optional remark on DH:  The DH in slide 18  leaks some info on k.  There is a fast method that, given g, p, and  g [c ] mod p, determine whether c is odd or even. So, adversary can infer whether (ab) is odd or even.  If it is odd, then both a and b must be odd. If it is even, at least one of them must be even.     Thus, in practice, always choose a and b that are even to avoid this leakage. (several crypto CTFs exploit this fact in their challenges) .",
  "20": "Forward Secrecy \u2022 DH based method meets the Forward Secrecy requirement. PKC based method couldn\u2019t. \u2022 Forward secrecy is an important requirement, and we will cover it in Tutorial. \u2022 TLS 1.3 mandates forward secrecy. 20",
  "21": "4.6 Authenticated Key-exchange Attack model: \u2022 Capability:  Mallory, \u2022 Goal: get session key and/or impersonate Alice/Bob 21 Alice Bob (1) Authenticated key exchange (in SSL/TLS, this is called handshake ) (2) Outcome of authenticated  key exchange is a common session key k (2) Outcome of authenticated  key exchange is a common session key k (3) Communication protected by k , via \u201cauthenticated encryption\u201d Mallory can sniff, modify Threat model \u2022 Capability: Can be sniff, modify throughout the session. \u2022 Goal:  Steal info of k. If attacker able to get k, then C-I of communication can be compromised. Not considered in the threat model, although eventually these are the eventually these are the info to be protected",
  "22": "Key-exchange alone can\u2019t guard against Mallory. \u2022 What if the adversary is malicious?  Example, a man-in-the- middle? 22 Alice Bob Mallory impersonating Alice impersonating Bob Key-exchange between Alice and Mallory established key kA A Key-exchange between Alice and Mallory established key kB B In this case,  Bob mistaken that Mallory is Alice and vice versa . Communication from Alice is encrypted using kA. A. Mallory can decrypt using k A and re-encrypt using kB.     Hence, Mallory can see and modify the and re-encrypt using kB.     Hence, Mallory can see and modify the B.     Hence, Mallory can see and modify the Hence, Mallory can see and modify the message.",
  "23": "Authenticated key-exchange \u2022 A key-exchange protocol assumes that the adversary can only sniff, but not malicious. \u2022 To prevent malicious Mallory, we need authenticated key-exchange. \u2022 It turns out that authenticated key-exchange can be easily obtained from existing key- exchange. \u2022 For DH based, this can be done by signing all communication using the private key. We have a special name for authenticated key-exchange that uses DH:  it is known as Station-To-Station Protocol  (STS). \u2022 For PKC-based, step (1) can be omitted and simply use Alice\u2019s existing public/private key.   Because only Alice has the private key, so, the entity that can correctly decrypt it must be Alice. 23",
  "24": "Station-to-station protocol  (Authenticated key-exchange based on DH) (Authenticated key-exchange based on DH) We assume both Alice and Bob have agreed on two public parameters,   a generator  g and a large (e.g. 1000 bits) prime p .   Both g and p are not secret and known to the public. Here, we consider unilateral  authentication.   Alice want to authenticate Bob. Can be easily extended to mutual authentication. 24 Alice Bob (4.1)          x (3.1) \u2022 Verify signature s \u2022 Compute k =  y a mod p (3.1) \u2022 Randomly chooses a \u2022 Compute x= g a mod p (4.2)        (y, s) (3.2) Compute k =  x b mod p (3.2) \u2022 Randomly chooses b \u2022 Compute y= g b mod p \u2022 Sign y to obtain signature s From certificate, Alice get Bob\u2019spublic key  Bob public (Bob public , Bob private ) Remark: This is unilateral authentication. Can extend it to mutual by making Alice signs her messages in step (4.1). (1) \u201cHi Bob, I want to connect\" (2) \u201chere is my certificate\u201d",
  "25": "PKC-based authenticated Key-exchange often called RSA-based 1. Alice indicates that she wants to connect. 2. Bob sends his public key ke e to Alice. 3. Alice carries out the following i. Randomly chooses a secret k , ii. Encrypts k using ke e . iii. Sends the ciphertext c to Alice. 4. Bob uses his private key kd d to decrypt and obtain k. 25 Alice Bob (2)  certificate. (3.i) Chooses a random secret k (3.ii) c =  Encrypt ( ke e , c ) (3.iii) c (4) k = Decrypt( kd d ,c) k e k d , k e (1) \u201cHi Bob, I want to connect\u201d.",
  "26": "Password based Authenticated Key Exchange \u2022 (Asymmetric) Previous authenticated key-exchange protocols such as Station-to-station are based on public key.  That is, an entity is considered authentic if it can convince the other that it know the private key of the associated public key. \u2022 (Symmetric) There are also symmetric key version, i.e both entities share a symmetric key.  An entity is authentic if it can prove to the other that it knows the key. \u2022 (Password) A special case of symmetric key is when the key is a password.   Password usually has very low entropy, and thus potentially could be vulnerable to \u201coffline\u201d dictionary attack (see tutorial). There are secure protocols, known as called \u201c Password-Authenticated Key agreement (PAKE) \u201d,  that prevent offline guessing and thus force the attacker to carry out online dictionary attack. https://en.wikipedia.org/wiki/Password-authenticated_key_agreement Remark: In tutorial, we note that offline dictionary can be carried out on the popular WPA-personal for home wifi, and there are also tools to do that (aircrack) . Strange that WPA standard doesn\u2019t use PAKE. Maybe due to higher computation in PAKE. 26",
  "27": "Summary:   Mutual Authenticated key exchange \u2022 Before the protocol : 1. Alice has a pair of public, private key (Apublic , Aprivate ). public , Aprivate ). , Aprivate ). private ). ). 2. Bob  has a pair of public, private key (Bpublic , Bprivate ). public , Bprivate ). , Bprivate ). private ). ). 3. Alice knows Bob public key and vice versa.  These two sets of keys are known as the Long-term key or Master key. \u2022 They carry out Authenticated key exchange protocol (e.g. STS). If an entity is not authentic, the other (e.g. STS). If an entity is not authentic, the other . If an entity is not authentic, the other will halt. \u2022 After the protocol : 1. Both A and B obtain a shared key k, known as the Session key. \u2022 Security Requirement. 1. (Authenticity) Alice is assured that she is communicating with an entity who knows Bprivate. private. 2. (Authenticity) Bob is assured that he is communicating with an entity who knows Aprivate. private. 3. (confidentiality) Attacker unable to get the session key. 27",
  "28": "4.7 Putting all together: Securing Communication Channel E.g. TLS 28",
  "29": "Channel Security Suppose we have a \u201cpublic channel\u201d.  The public channel facilitates communication, however, there are presences of Mallory. Now, using the above unsecure public communication as the carrier, can we add a layer of crypto primitives on the messages, so that the channel is as secure as a \u201cprivate channel\u201d?      Yes. (By definition: A public channel has a Mallory;  A private channel is free from Eve and Mallory) 29",
  "30": "Bob wants to visit a website alice.com. Alice is using the free wifi in a caf\u00e9 called Mallory. Everyone can access the free wifi and thus it is a public channel. We want to secure the public channel using crypto. TLS/SSL secure the public channel in this way: (https uses TLS) (https uses TLS) (1) Using long-term keys (i.e. Alice\u2019s public and private key), carry out authenticated key-exchange (aka handshake in TLS).  Outcomes are: \u2022 Bob is convinced that she is interacting with Alice. \u2022 Both Alice and Bob have a shared session key. (2) Subsequent communication protected by the session key. More details in next slide: 30",
  "31": "Alice wants to visit Bob.com :   How TLS does it. (Step 0) 0) Alice obtains bob.com \u2019s  public key securely.  This is done by having Bob sending his certificate to Alice. (Step 1) 1) Alice and bob.com carry out unilateral authenticated key exchange protocol with Bob\u2019s private/public key.  After the protocol, both Bob and Alice obtain  a shared key k , which could come in the form of k =\u27e8 \u27e8 k1 , k2 \u27e9  where where k1 is the secret key of the MAC, and k2 is the secret key of  the symmetric-key encryption, or a single key k when authenticated encryption (e.g. GCM) is in used.     These keys are called the session keys .   By property of the protocol, Alice is convinced that only Bob and herself know the session key.        Here (unilateral authentication), Bob doesn\u2019t care about Alice\u2019s authenticity. (Step 2) 2) Subsequent interactions between Alice and Bob.com will be protected by the session keys and a sequence number.  Suppose m1, m2, m3, \u2026 are the sequence of message exchanged, the actual data to be 1, m2, m3, \u2026 are the sequence of message exchanged, the actual data to be , m2, m3, \u2026 are the sequence of message exchanged, the actual data to be 2, m3, \u2026 are the sequence of message exchanged, the actual data to be , m3, \u2026 are the sequence of message exchanged, the actual data to be 3, \u2026 are the sequence of message exchanged, the actual data to be , \u2026 are the sequence of message exchanged, the actual data to be sent for  mi is i is is Ek1 ( k1 ( ( i \u2225  m )    \u2225     mack2 (  Ek1 ( m )    \u2225     mack2 (  Ek1 ( \u2225     mack2 (  Ek1 ( mack2 (  Ek1 ( k2 (  Ek1 ( (  Ek1 ( k1 ( ( i \u2225 m)   ) m)   ) where i is the sequence number. For GCM mode or other authenticated encryptions, the message to be sent is simply Ek ( k ( ( i \u2225  m ) m ) \u2022 \u2225 refer to string concatenation. \u2022 The above is known as \u201cencrypt-then-mac\u201d.  There are other variants: \u201cmac-then-encrypt\u201d and \u201cmac-and-encrypt\u201d. Using the wrong variant might leak info.  It is recommended to use \u201cauthenticated encryption\u201d such as AES GCM mode. 31 Recommended. Still in use but not recommended..",
  "32": "32 Alice Bob.com authenticated key-exchange k =\u27e8 k1,k2 \u27e9 \u27e8 k1,k2 \u27e9 k1,k2 \u27e9 \u27e9 \u201c1. message\u2026.\u201d \u201c2. message\u2026.\u201d \u201c35.  close connection.\u201d \u2026 Authenticity protected by mac using k2 as key Confidentiality protected by encryption using k1 as key. Question: What is the role of the sequence number 1,2,3, \u2026  and the last message \u201cclose connection\u201d? The data eventually sent is Ek1 (\u201d1. message etc\u201d ) k1 (\u201d1. message etc\u201d ) (\u201d1. message etc\u201d ) \u2225 mack2 (Ek1 (\u201d1. message etc\u201d ))      or   using authenticated encryption k2 (Ek1 (\u201d1. message etc\u201d ))      or   using authenticated encryption (Ek1 (\u201d1. message etc\u201d ))      or   using authenticated encryption k1 (\u201d1. message etc\u201d ))      or   using authenticated encryption (\u201d1. message etc\u201d ))      or   using authenticated encryption For encrypt-then-mac, two keys required. For authenticated encryption, one key is sufficient.",
  "33": "Relationship among  TLS/SSL/https \u2022 SSL and Transport Layer Security ( TLS ) are protocols that secure communication using cryptographic mean. \u2022 SSL is the predecessor of TLS. \u2022 Https is built on top of TLS. Remarks: \u2022 SSL 3.0 has a few vulnerabilities in its crypto implementation.  Vulnerable to padding oracle attack, etc. (e.g CVE -2014-8730).   TLS 1.0 is an upgraded version of SSL3.0 (in 1999). But TLS 1.0 allows fallback to SSL3.0 (aka downgrading attack), and thus TLS 1.0 is also vulnerable.  So, to be secure, at least TLS 2.0.   See https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.0 33",
  "34": "TLS handshake (authenticated key exchange) 34 https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.1.0/com.ibm.mq.doc/sy10660_.htm Server\u2019s public key Negotiation of the type of crypto  to be used, e.g. whether it is STS, RSA, and the key length. Here, Client proposes the suite to be used. Server confirms or counter-proposes the crypto suite. Authenticated key- exchange",
  "35": "4.8 Forward Secrecy 35",
  "36": "Forward Secrecy is a security requirement on authenticated key exchange.  Forward Secrecy considers this attack scenario. 1. Eve has logged the communication between two entities a) X : Authenticated key exchange based on the master key, km m b) Y : Subsequence messages protected by the session key, k s 2. Eve obtains the master km m .  (Eve somehow obtains it through other means, e.g. Eve successfully hacks into the server). 3. From km m , X , and Y , Eve wants to recover the plaintext in Y .  (if Eve can obtain (if Eve can obtain ks s , then Eve can recover the plaintext) If  Eve cannot succeed, then we say that the authenticated key exchange  achieve Forward Secrecy . 36 Alice Bob Master key km m X : authenticated key exchange Y : authenticated encryption Master key km m Session key k s Session key k s Eve X , Y , km m Eve Plaintext of Y (or k s ) At this point, Eve doesn\u2019t have km m",
  "37": "\u2022 PKC-based authenticated key-exchange does not achieve forward secrecy. (Tutorial 6) \u2022 Station-to-Station key exchange achieves forward secrecy - (proof omitted) - If an attacker can solve CDH (slid 18),  then the attacker can compromise forward secrecy of station-to-station. 37"
}