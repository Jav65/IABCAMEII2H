{
  "1": "Topic 7 Call Stack 7.1   Background 7.2   Compromising control flow 7.3   Stack (aka Execution Stack, Call Stack) https://en.wikipedia.org/wiki/Call_stack We have seen  confidentiality, authenticity of data and  availability of services. Now, integrity of processes. This background is required to appreciate buffer overflow and stack smash.",
  "2": "Summary and takeaways \u2022 Demonstrate how process integrity can be compromised by modifying values in memory. \u2022 Call stack facilitates function calls by maintaining and keeping track of runtime environments . \u2022 An element in the stack is a \u201cstack frame\u201d. It contains runtime info such as control flow info (return address), local variables, and parameters.      Malicious modification of those info would have significant consequence (next lecture on stack smash + buffer overflow). \u2022 Stack Smack : Due to how OS/compiler maintain the runtime environments, there are opportunities for an attacker to compromised its victim\u2019s call stack (e.g. buffer overflow of  local variables into return address). 2",
  "3": "7.1 background Many concepts in software security requires good understanding of the \u201cruntime environment\u201d. 3",
  "4": "Code vs Data \u2022 Modern computers are based on the Von Neumann computer architecture. The code are treated as data and both are stored in the memory. There are no clear distinction of code and data. The \u201cprogram counter\u201d indicate location of next instruction to be executed. 4 processor Program Counter Memory data code 0000 0001 0002 \u2026 Memory address",
  "5": "Control Flow \u2022 The program counter (aka Instruction Pointer)  is a register (i.e. small & fast memory within the processor) that stores the address of the next instruction. \u2022 The following 3 steps  keep looping: 1. The processor fetches  the data in location pointed by the PC. 2. Increase the PC by 1. 3. The processor treat the fetched data as an instruction and execute it. Note that by looping the above, instructions would be executed sequentially in the memory. \u2022 During execution, program counter could also be changed by the fetched instruction, including [*] , 1. (direct branch)   replaced by a constant value specified in the instruction; 2. (indirect branch) replaced by a value fetched from the memory. There are many different forms of indirect branch. *: for simplicity, we omit conditional branch and call/return here. 5 processor Program Counter instr  1 instr 2 instr 3 Memory",
  "6": "illustration 1000 1001 1002 1003 1004 branch to 1008 1005 1006 1007 1008 branch to ($6123) 1009 1010 ..... 6123 1001 ..... 6 some binary string that represent \u201cinstructions\u201d Remarks :  This is an over-simplified abstraction.  E.g.  instructionscan be of variable length. can be of variable length. The intended execution path. (Control Flow) addresses direct indirect code data",
  "7": "7.2 Control flow integrity 7",
  "8": "Compromising  memory integrity \u2192 control flow integrity \u2022 Suppose an attacker can modify some memory,  the attacker could compromise the execution integrity by either: o directly modifies code in the memory; or o modifying the address in indirect branch. \u2022 E.g., by exploiting buffer overflow, the attacker could write to certain memory that the attacker originally doesn\u2019t have access to. \u2022 While possible, it is still not  easy for an attacker to compromise memory integrity. In addition, it may come with some restrictions. For e.g. attackers can only write to some specific locations, or the attacker can only write a sequence of consecutive bytes, or the attacker can write but not read, etc. 8",
  "9": "Possible Attack Mechanisms Let us assume that the attacker has the capability to write to some memory locations and wants to compromise the execution integrity.  The attacker could: ( Attack 1 )   Overwrite existing execution code portion with malicious code; or ( Attack 2 )   Overwrite a piece of control-flow information: (2a)   Replace a memory location storing a code address that is used by a direct jump ( 2b )  Replace a memory location storing a code address that is used by an indirect jump The above three attacks are illustrated in the next few slides. When Attack (2b) is carried out on stack, it is aka Stack smashing . 9",
  "10": "Attack 1 (replace the code) 1000 1001 1002 1003 1004 branch to 1008 1005 1006 1007 1008 Normal code 1009 Normal code 1010 .... 1011 1012 ..... 10 1000 1001 1002 1003 1004 branch to 1008 1005 1006 1007 1008 Malicious code 1009 Malicious code 1010 .... 1011 1012 .....",
  "11": "Attack 2a, 2b:  Normal control flow before being attacked. 11 1000 1001 1002 1003 1004 branch to 1008 1005 1006 1007 1008 branch to ($6123) 1009 \u2026.. 6123 1001 6124 ..... Intended execution path. (Control Flow)",
  "12": "Attack 2a (Memory locations that store the code being modified) (Memory locations that store the code being modified) mory locations that store the code being modified) the code being modified) 12 1000 1001 1002 1003 1004 branch to 8000 1005 1006 1007 1008 branch to ($6123) 1009 .... 6123 1001 ..... ..... 8000 An existing library, when called in this context would lead to malicious outcome. modified execution path. content modified by attacker,",
  "13": "Attack 2b (Memory locations that store the addresses  being modified) (Memory locations that store the addresses  being modified) y locations that store the addresses  being modified) locations that store the addresses  being modified) 13 1000 1001 1002 1003 1004 branch to 1008 1005 1006 1007 1008 branch to ($1011) 1009 .... 6123 8000 ..... ..... 8000 An existing library, when called in this context would lead to malicious outcome. modified execution path. modified by attacker, e.g. via buffer overflow. code data code",
  "14": "7.3 Stack (aka Execution Stack, Call Stack) See: https://en.wikipedia.org/wiki/Call_stack 14",
  "15": "Functions \u2022 A function can be called from  different part of the program,  and even  recursively. \u2022 Question 1 : how does the control flow knows where it should return to after a function is  is completed? \u2022 Question 2 : where are the function\u2019s \u201cruntime environment\u201d stored. That is, where are the arguments and local variables ?  (recap that in a recursive function, a local (recap that in a recursive function, a local variable could concurrently hold many values.) \u2022 These are managed by \u201ccall stack\u201d. void sample_function(void) { char buffer[10]; printf(\u201cHello!\\n\u201d); return; } main() { sample_function(); printf(\u201cLoc 1\\n\u201d); sample_function(); printf(\u201cLoc 2\\n\u201d); } ------------------------ int printf (\u2026.) {\u2026; return; } 15 (1) (2) (3) (4)",
  "16": "Remark: Stack \u2022 Stack is a data structure resides in the memory. \u2022 A call-stack stores runtime environment for each  function instance.  The runtime environment of an instance is stored in a single \u201cstack frame\u201d. A frame consists of multiple bytes. \u2022 Stack pointer is a variable that stores location of the first element. There are two operations in stack: Push and Pop.      (Last-In-First-Out). 16 1000 xxx 1001 xxx 1002 xxx 1003 xxx 1004 xxx 1005 xxx 1006 xxx 1007 xxx ..... stacker pointer 1002 push pop Note : In this example, the stack grows \u201cupward\u201d.",
  "17": "Call stack \u2022 Recap that stack is last-in-first-out. \u2022 During execution, a Call Stack is maintained to keep track of the runtime environment. \u2022 The runtime environment (let\u2019s call it a stack frame ) of an instance includes: - Parameters to be  passed in and result to be returned - Return address  (i.e. the address to return to after the function completed.) (i.e. the address to return to after the function completed.) - Local variables of functions (For efficiency, the stack frame include a pointer to the previous stack frame. This pointer is included for efficiency. Let\u2019s ignore the role of this. We mentioned it here since most documents mentioned this) \u2022 (push) When a function is being called, its stackframe is pushed in. \u2022 (pop)   When the function completed, the stack frame is poped  out. 17",
  "18": "Illustration. When a function is invoked, the runtime environment is \u201cpushed\" into the stack. E.g. for the following segment of C program: int Drawline( int a) {int b =1; .. } int main() { Drawline (5); } 18 Local variable b ret Previous Frame pointer, i.e. Location of the caller frame. return address Parameters: 5 top of stack When the function Drawline(5) is invoked, the followings steps are carries out: (1) These data are pushed into the stack in this order: \u2022 the parameter (which is \u201c5\u201d), \u2022 the \u201c return address \u201d (i.e. value of program counter), and \u2022 the value of the local variable b (which is 1). (2) The control flow branches to the code of \u201cDrawline\u201d. (3) Execute \u201cDrawline\u201d. (4) After \u201cDrawline\u201d is completed, pops out the variables, \u201c return address \u201d and parameter. (5) Control flow branches to \u201c return address \u201d. Frame pointer (due to some efficiency consideration, there is a frame pointer that points to previous frame.  For simplicity, let us ignore frame pointer.  We mention it here because most text would include it.)",
  "19": "int func1( int a) {int b =253; func2( 2); } int func2( int a) {int b =15; func3( 1); } int func3( int a) {int b =0; } int main() { func1(3); } 19 Info on func1 Info on func1 Info on func2 Info on func1 Info on func2 Info on func1 time func1(3) is called func2(2) is called func3(1) is called func3(1) returned func2(2) returned func1(1) returned Info on func1 Info on func2 Info on func3 Func 1 \u2026 \u2026 \u2026 \u2026 \u2026 Return memory Func 2 \u2026 \u2026 .. \u2026 .. return Func 3 \u2026 \u2026. \u2026 \u2026 \u2026 return PC main",
  "20": "Illustration n * 20 1000 1001 1002 1003 1004 Push 5 to stack 1005 Push 1008 to stack 1006 Push 1 to stack 1007 Branch 5000 1008 \u2026 1009 \u2026. 5000 \u2026 ..... ... pop \u2026.. Branch $(stack pointer+some offset) ..... Code of \u201cDrawline\u201d Return address Calling of Drawline(5) Local variable b previous frame pointer Return address Parameter top of stack *: This slide gives a simplified view. For more details, see http://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html  or http://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html  or or https://en.wikipedia.org/wiki/Stack_buffer_overflow Local variable",
  "21": "Security implication. \u2022 Using buffer overflow on the local variables, attacker could modify the stack.  (This is called stack smash). \u2022 Stack smash has two effects: \u2022 If return address is modified,  the control flow integrity is compromised. \u2022 If local variables  are modified, the computed result would be wrong. 21"
}