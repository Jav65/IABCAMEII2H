{
  "1": "C2107 Tutorial 2 Answer(Encryption) E.-C. Chang, School of Computing, NUS August 19, 2025 1. This is an example of the ciphertext xor-ing attack described in Lecture 1: C 1 \u2295 C 1 (by omitting the IV) = (by omitting the IV) = P 2 \u2295 P 3 = 11110000. = 11110000. Notice that the attack is applicable because: (a) a stream cipher is em- ployed; (b) the same secret key and IV are used for generating the two ciphertexts. 2. For each pair of k 1 and and k 2, we need 2 encryptions and 2 decryption. There , we need 2 encryptions and 2 decryption. There is a total of 2 [112] pairs. Using a straightforward method of applying 2 en- cryptions and 2 decryptions for each pairs, the overall is 2 [114] cryptographic operations. We can do slightly better than that. One can exhaustively enumerate k 1, , and for each k 1, exhaustively search all , exhaustively search all k 2. So, the number of encryptions . So, the number of encryptions will be (number of encryptions using k 1) + (number of encryptions using ) + (number of encryptions using k 2) = 2 ) = 2 [56] + 2 [112] \u2248 2 [112] . We need the same number of operations for k 3 and k 4. So total is approximately 2 . So total is approximately 2 [112] \u00d7 2 = 2 [113] . Remarks: (a) If applied 3 times, meet-in-the-middle needs approximately 2 [112] op- erations. So, increase from 3 to 4 times only increase the \u201cdifficulty\u201d from 2 [112] to 2 [113] (or \u201cbit-strength\u201d from 112 to 113). (b) What about applying 2 t \u2212 \u2212 1 times vs applying it 2 t times, when t = 3 , 4 , . . . . 3. (Remark: The question doesn\u2019t state precisely what type of info can be sniffed from the (Remark: The question doesn\u2019t state precisely what type of info can be sniffed from the communication channel. From the context, it should be clear that the sniffed data are the ciphertext.) \u2022 The block size for The block size for \u2013 \u201cbuy\u201d message is 1. \u2013 \u201csell\u201d message is 1. \u2013 \u201csell e verything\u201d message is 2. \u2013 \u201chold a nd s ee\u201d message is 2. So, including IV, the ciphertext size corresponds to \u201cbuy\u201d is 2 blocks and so on. Now simply from ciphertext block size, the attacker can know whether the message is in { sell, buy } or in { sell e verything, hold a nd s ee } . Using ciphertext\u2019s size as extra information is an example of side-channel attack. This leakage present in both CBC and CTR setting.",
  "2": "(a) ( CBC mode). Due to the re-start and the way IV is generated, attacker can get a few ciphertexts with the same IV. Note that IV is sent in clear and so attacker will know whether the IVs of two ciphertexts are the same. Let\u2019s consider many ciphertexts (including IV) with the same block- size 3 that are captured over past few days with the same IV. The first block is the IV, and the 2nd, 3rd are output from AES. Let\u2019s consider a particular IV, and the ciphertexts with that IV. The attacker groups those ciphertexts whose 2nd block are exactly the same in a group. Next, the attacker declares that ciphertext in the group corresponds to \u201csell e verything\u201d ; and ciphertext not in the group as \u201chold a nd s ee\u201d. Remark: \u2022 The above works because due to same IV, the ciphertext is the The above works because due to same IV, the ciphertext is the same iff the plaintext is the same. \u201csell e verything:\u201d is 16 bytes and fit into a block. Furthermore, it appears as first block in the plaintext. By CBC, they will be encrypted to the same ciphertext. However, \u201chold a nd s ee:\u201d is less than 16 bytes and will be padded with the days that likely to be different. So the ciphertext likely to be different. Note that the 3rd block would be different. \u2022 Unfortunately, the above can\u2019t apply to \u201cbuy\u201d and \u201csell\u201d. Unfortunately, the above can\u2019t apply to \u201cbuy\u201d and \u201csell\u201d. \u2022 Whether attacker know the date or not would not affect the Whether attacker know the date or not would not affect the outcome. \u2022 (minor remark) There could be some cases that due to the same \u201cday\u201d in the date, the first block of \u201chold a nd s ee:\u201d are the same for two different capture. In such cases, attacker would observe two groups of ciphertexts having the same first block. Likely that the larger on is \u201csell e verything:\u201d. (b) (CTR mode). Drawing a figure would be much clearer for this question. Suppose two instructions are consecutively encrypted, and the first ciphertext consists of 3 blocks (including the IV). Let the first ciphertext be ( v, c 1 , c 2) and the corresponding plaintext is ) and the corresponding plaintext is p 1 \u2225p p 2. . Let the third ciphertext be ( v + 1 , c 3) or ( ) or ( v + 1 , c 3 , c 4) depending its ) depending its size, and the corresponding plaintext of c 3 is is p 3. . Note that by CTR mode, c 2 = = p 2 \u2295 AES( v + 2). Furthermore, c 3 = = p 3 \u2295 AES( v + 2). That is, the \u201div\u201d is the same. So, similar to the \u201czebra\u201d example in lecture note, the attacker can obtain p 2 \u2295 p 3. . 4. v = IV \u2295\u27e8 \u2295\u27e8 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , t, 08 , 08 , F7 , 0C , 0C , 0C , 0C \u27e9 and output t \u2295 \u2295 08. That is, (a) For t = 0 to FF 2",
  "3": "(b) let v = IV \u2295\u27e8 \u2295\u27e8 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , t, 08 , 08 , F7 , 0C , 0C , 0C , 0C \u27e9 . (c) send v\u2225c \u2225c c to oracle. (d) If yes , output t \u2295 \u2295 08. To understand the algo, you might want to draw the decryption process (i.e. the flow chart of Dk k ( c ) \u2295 v ), assume b 9 is some value (e.g. 04) and is some value (e.g. 04) and then trace the loop. 5. Assume the ciphertext (including the IV) is three blocks. Unlike the lec- ture note, here, we modify the 2nd block of the ciphertext instead of the IV. Method 1 : Assume that the length is i , and test it. Test one by one starting from 1,...,16. (a) for i in 1,2,3...,16. (b) Change the ( i )-th byte of the 2nd block and query the oracle. If the reply is \u201cinvalid\u201d, declare the number of padded bytes to be 17 \u2212 i and break from the loop. Method 2 : Improved version. Use binary search to find the i that goes from valid to invalid. (optional remark: can\u2019t do better than binary search. There are 16 possi- ble outcomes, and every query would eliminate at most halve.) 6. There are many. E.g. CVE-2023-41097. \u2018 \u2018An Observable Timing Dis- crepancy, Covert Timing Channel vulnerability in Silabs GSDK on ARM potentially allows Padding Oracle Crypto Attack on CBC PKCS7.This is- sue affects GSDK: through 4.4.0. \u201d 3"
}