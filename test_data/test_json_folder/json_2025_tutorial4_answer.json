{
  "1": "C2107 Tutorial 4 (Hash, mac) Solution Chang E.-C., School of Computing, NUS September 17, 2025 1. ( Pitfalls: \u201cpseudo random\u201d could be \u201cdeterministic\u201d. ) To generate the IV and key, Bob insecurely employed H by giving a fixed string of 160 zeros as the seed s . Although hash function (e.g SHA family) is often called \u201cpseudo random\u201d, note that it is \u201cdeterministic\u201d. Hence, the attacker can simply derive the key by repeating Bob\u2019s key generation process, i.e. by taking the leading 128 bits of H ( H (000 . . . 000)). 2. ( Still insecure: (1) seed entropy too low. (2) programming error. ) \u2022 If an adversary knows the time, which is possible in practice, then If an adversary knows the time, which is possible in practice, then he/she can derive the key. If the adversary knows only the approximate time, still he/she can exhaustively search all possible times. \u2022 Even if the adversary knows nothing about the time, it is still possible Even if the adversary knows nothing about the time, it is still possible to brute force the variable s . This is since int data type in C is only either 2-byte (16-bit) or 4-byte (32-bit) long depending on the platforms used. It is feasible to exhaustive search 32 bits. 3. ( Information on secret key is used to derive other data, instead of solely for encryption. ) Bob\u2019s implementation still insecure as an attacker can still find the key k used. Notice that the key k is derived by applying H to the 160-bit x 1 = = v || r || r r , where v is the 128-bit IV and r is a 32-bit string. Since the attacker knows the IV v , then he/she will just need to guess the generated r . Given that r is only 32 bits, the attacker is therefore able to exhaustively search r . For each r , construct x [\u2032] 1 [=] [ v][ ||][ r] [ ||][ r] [ r] [, and compute] [ x][\u2032] [\u2032] 2 [=] [ H] [(] [x][\u2032] [\u2032] 1 [). Then,] test whether the first 128-bit of x [\u2032] 2 [is the correct key] [ k] [.] 4. ( Online vs offline attack ) (a) Yes. According to RFC 4086 recommendation (lecture note), 30 bits is sufficient to be secure against online attack. Following the guideline in our course, 49 bits is sufficient. There are a total of (26 \u00d7 2 + 10 = 62) alphanumeric symbols. So each character in the password contribute to at least 5.9 bits. 10 characters would be 59 bits and hence more than sufficient. (To be rigorous, note that total number of passwords (To be rigorous, note that total number of passwords is 62 [10] . Assuming each password is equally likely, the entropy would be log2 62 2 62 62 [10] > 10 \u00d7 5 . 9 = 59.) )",
  "2": "(b) 10 characters not sufficient. It is possible to carry out offline attack. According to the assumption of attack scenario, attacker can first sniff and get c, h . Next, the attacker exhaustively search for the password p s.t. (1) k = SHA3 ( p ), (2) r = DEC ( k, c ), (3) h = mac ( k, r ) without interacting with the system. The p that meets the three equality tests must be the correct password. The entropy of the password is log2 62 2 62 62 [10] < 5 . 96 \u00d7 6 = 59 . 6. Using the guideline in Tutorial 3, at least 128 bits are required. (c) Wrong implementation. If r is always 0, the mac h is always the same. So, the attacker can simply conduct a Replay Attack . Just send in previous h . (Remark: This demonstrate replay attack. Simply sniff and replay as it is. ) (Optional: r supposes to provide freshness in the authentication protocol.) (d) Unfortunately, WPA2 personal employ a similar protocol and is vul- nerable to offline dictionary attack. So, a longer password required. (e) Remark. To mitigate exhaustive search on the password, it is com- mon to deploy a hash function that is intentionally designed to be very slow. Such hash function is aka Key Derivation Function (KDF). More on KDF in next tutorial. (f) Optional Remarks. i. Most wifi access point deploy WPA2 to secure the wireless con- nection. There are variants of WPA2 that uses LEAP or PEAP (LEAP is vulnerable to offline attack and PEAP is secure against offline attacks). Fortunately, NUS uses PEAP. To prevent the offline attack, PEAP first makes sure that the server is authentic, and then all communication is protected by a key generated by \u201cauthenticated key-exchange\u201d (to be covered later). The pass- word (or hash of it) can then next send via the secured channel. For this, we need the client to know the server\u2019s public key, and thus the need of \u201ccertificate\u201d. ii. This question considers a passive eavesdropper who sniff the h and r . In practice, an attacker might setup a fake client or server. Unlike the passive eavesdropper, the fake client (or server) doesn\u2019t have to follow the protocol and thus might be stronger. 5. ( Stream cipher is malleable ) Recap the security requirement of mac: After seen multiple valid pairs of messages and their corresponding mac, it is still difficult for the attacker to forge a mac for message not seen before . One way to show/prove the insecurity of a mac is by giving a successful attack. That is, we have to give an algorithm/attack that, when given 2",
  "3": "many pairs of message and mac, the algorithm can generate a new message and its valid mac. Suppose the attacker knows a pair of valid message m and its mac t = mac ( k, m ) = Enc k ( H ( m )) = r \u2295 \u2295 H ( m ) where r is the pseudorandom sequence generated by the stream cipher. The attacker next chooses another message \ufffd \ufffd m where \ufffd \ufffd m \u0338 \u0338 = m . The attacker computes \ufffd t = t \u2295 \u2295 H ( \ufffd m ) \u2295 H ( m ) Note that \ufffd t is a valid mac for \ufffd \ufffd m , since \ufffd t = t \u2295 \u2295 H ( \ufffd m ) \u2295 H ( m ) = r \u2295 \u2295 H ( m ) \u2295 H ( \ufffd m ) \u2295 H ( m ) = r \u2295 \u2295 H ( \ufffd m ) So, the attacker has constructed a new pair of message \ufffd \ufffd m and its valid mac [\ufffd] t . In other words, the attacker can forge a valid pair that it has not seen before. This violates the security definition and thus not a secure mac. Remark. There are constructions of mac that use encryption. That is, certain choices of encryption can give a secure mac. 3"
}